{
  "version": 3,
  "sources": ["../../.pnpm/cipher-base@1.0.6/node_modules/cipher-base/index.js"],
  "sourcesContent": ["'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\nvar Transform = require('stream').Transform;\nvar StringDecoder = require('string_decoder').StringDecoder;\nvar inherits = require('inherits');\n\nfunction CipherBase(hashMode) {\n\tTransform.call(this);\n\tthis.hashMode = typeof hashMode === 'string';\n\tif (this.hashMode) {\n\t\tthis[hashMode] = this._finalOrDigest;\n\t} else {\n\t\tthis['final'] = this._finalOrDigest;\n\t}\n\tif (this._final) {\n\t\tthis.__final = this._final;\n\t\tthis._final = null;\n\t}\n\tthis._decoder = null;\n\tthis._encoding = null;\n}\ninherits(CipherBase, Transform);\n\nvar useUint8Array = typeof Uint8Array !== 'undefined';\nvar useArrayBuffer = typeof ArrayBuffer !== 'undefined'\n\t&& typeof Uint8Array !== 'undefined'\n\t&& ArrayBuffer.isView\n\t&& (Buffer.prototype instanceof Uint8Array || Buffer.TYPED_ARRAY_SUPPORT);\n\nfunction toBuffer(data, encoding) {\n\t/*\n\t * No need to do anything for exact instance\n\t * This is only valid when safe-buffer.Buffer === buffer.Buffer, i.e. when Buffer.from/Buffer.alloc existed\n\t */\n\tif (data instanceof Buffer) {\n\t\treturn data;\n\t}\n\n\t// Convert strings to Buffer\n\tif (typeof data === 'string') {\n\t\treturn Buffer.from(data, encoding);\n\t}\n\n\t/*\n\t * Wrap any TypedArray instances and DataViews\n\t * Makes sense only on engines with full TypedArray support -- let Buffer detect that\n\t */\n\tif (useArrayBuffer && ArrayBuffer.isView(data)) {\n\t\t// Bug in Node.js <6.3.1, which treats this as out-of-bounds\n\t\tif (data.byteLength === 0) {\n\t\t\treturn Buffer.alloc(0);\n\t\t}\n\n\t\tvar res = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n\t\t/*\n\t\t * Recheck result size, as offset/length doesn't work on Node.js <5.10\n\t\t * We just go to Uint8Array case if this fails\n\t\t */\n\t\tif (res.byteLength === data.byteLength) {\n\t\t\treturn res;\n\t\t}\n\t}\n\n\t/*\n\t * Uint8Array in engines where Buffer.from might not work with ArrayBuffer, just copy over\n\t * Doesn't make sense with other TypedArray instances\n\t */\n\tif (useUint8Array && data instanceof Uint8Array) {\n\t\treturn Buffer.from(data);\n\t}\n\n\t/*\n\t * Old Buffer polyfill on an engine that doesn't have TypedArray support\n\t * Also, this is from a different Buffer polyfill implementation then we have, as instanceof check failed\n\t * Convert to our current Buffer implementation\n\t */\n\tif (\n\t\tBuffer.isBuffer(data)\n\t\t\t&& data.constructor\n\t\t\t&& typeof data.constructor.isBuffer === 'function'\n\t\t\t&& data.constructor.isBuffer(data)\n\t) {\n\t\treturn Buffer.from(data);\n\t}\n\n\tthrow new TypeError('The \"data\" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');\n}\n\nCipherBase.prototype.update = function (data, inputEnc, outputEnc) {\n\tvar bufferData = toBuffer(data, inputEnc); // asserts correct input type\n\tvar outData = this._update(bufferData);\n\tif (this.hashMode) {\n\t\treturn this;\n\t}\n\n\tif (outputEnc) {\n\t\toutData = this._toString(outData, outputEnc);\n\t}\n\n\treturn outData;\n};\n\nCipherBase.prototype.setAutoPadding = function () {};\nCipherBase.prototype.getAuthTag = function () {\n\tthrow new Error('trying to get auth tag in unsupported state');\n};\n\nCipherBase.prototype.setAuthTag = function () {\n\tthrow new Error('trying to set auth tag in unsupported state');\n};\n\nCipherBase.prototype.setAAD = function () {\n\tthrow new Error('trying to set aad in unsupported state');\n};\n\nCipherBase.prototype._transform = function (data, _, next) {\n\tvar err;\n\ttry {\n\t\tif (this.hashMode) {\n\t\t\tthis._update(data);\n\t\t} else {\n\t\t\tthis.push(this._update(data));\n\t\t}\n\t} catch (e) {\n\t\terr = e;\n\t} finally {\n\t\tnext(err);\n\t}\n};\nCipherBase.prototype._flush = function (done) {\n\tvar err;\n\ttry {\n\t\tthis.push(this.__final());\n\t} catch (e) {\n\t\terr = e;\n\t}\n\n\tdone(err);\n};\nCipherBase.prototype._finalOrDigest = function (outputEnc) {\n\tvar outData = this.__final() || Buffer.alloc(0);\n\tif (outputEnc) {\n\t\toutData = this._toString(outData, outputEnc, true);\n\t}\n\treturn outData;\n};\n\nCipherBase.prototype._toString = function (value, enc, fin) {\n\tif (!this._decoder) {\n\t\tthis._decoder = new StringDecoder(enc);\n\t\tthis._encoding = enc;\n\t}\n\n\tif (this._encoding !== enc) {\n\t\tthrow new Error('canâ€™t switch encodings');\n\t}\n\n\tvar out = this._decoder.write(value);\n\tif (fin) {\n\t\tout += this._decoder.end();\n\t}\n\n\treturn out;\n};\n\nmodule.exports = CipherBase;\n"],
  "mappings": "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",
  "names": ["import_dist"]
}
