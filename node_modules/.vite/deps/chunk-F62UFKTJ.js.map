{
  "version": 3,
  "sources": ["../../.pnpm/vite-plugin-node-polyfills@0.23.0_rollup@4.42.0_vite@5.4.19_@types+node@20.19.0_/node_modules/vite-plugin-node-polyfills/node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js", "../../.pnpm/vite-plugin-node-polyfills@0.23.0_rollup@4.42.0_vite@5.4.19_@types+node@20.19.0_/node_modules/vite-plugin-node-polyfills/node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js", "../../.pnpm/vite-plugin-node-polyfills@0.23.0_rollup@4.42.0_vite@5.4.19_@types+node@20.19.0_/node_modules/vite-plugin-node-polyfills/node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js", "../../.pnpm/vite-plugin-node-polyfills@0.23.0_rollup@4.42.0_vite@5.4.19_@types+node@20.19.0_/node_modules/vite-plugin-node-polyfills/shims/buffer/index.ts", "../../.pnpm/vite-plugin-node-polyfills@0.23.0_rollup@4.42.0_vite@5.4.19_@types+node@20.19.0_/node_modules/vite-plugin-node-polyfills/shims/global/index.ts", "../../.pnpm/vite-plugin-node-polyfills@0.23.0_rollup@4.42.0_vite@5.4.19_@types+node@20.19.0_/node_modules/vite-plugin-node-polyfills/node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/crypto.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/utils.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/_md.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/_u64.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/sha2.ts", "../../.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/src/utils.ts", "../../.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/src/abstract/modular.ts", "../../.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/src/abstract/curve.ts", "../../.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/src/abstract/edwards.ts", "../../.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/src/abstract/hash-to-curve.ts", "../../.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/src/abstract/montgomery.ts", "../../.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/src/ed25519.ts", "../../vite-plugin-node-polyfills/node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js", "../../vite-plugin-node-polyfills/node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js", "../../vite-plugin-node-polyfills/node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js", "../../vite-plugin-node-polyfills/shims/buffer/index.ts", "../../../src/globalPolyfills.ts", "../../.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/src/sha512.ts"],
  "sourcesContent": ["'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n", "/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n", "/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\nconst { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new GlobalUint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, GlobalUint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new GlobalUint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (GlobalArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, GlobalArrayBuffer) ||\n      (value && isInstance(value.buffer, GlobalArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof GlobalSharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, GlobalSharedArrayBuffer) ||\n      (value && isInstance(value.buffer, GlobalSharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, GlobalUint8Array.prototype)\nObject.setPrototypeOf(Buffer, GlobalUint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, GlobalUint8Array)) {\n    const copy = new GlobalUint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new GlobalUint8Array(array)\n  } else if (length === undefined) {\n    buf = new GlobalUint8Array(array, byteOffset)\n  } else {\n    buf = new GlobalUint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, GlobalUint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, GlobalUint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, GlobalUint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        GlobalUint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, GlobalUint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof GlobalUint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof GlobalUint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    GlobalUint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n", "import {\n  Blob,\n  BlobOptions,\n  Buffer,\n  File,\n  FileOptions,\n  INSPECT_MAX_BYTES,\n  // eslint-disable-next-line n/no-deprecated-api\n  SlowBuffer,\n  TranscodeEncoding,\n  atob,\n  btoa,\n  constants,\n  isAscii,\n  isUtf8,\n  kMaxLength,\n  kStringMaxLength,\n  resolveObjectURL,\n  transcode,\n// eslint-disable-next-line unicorn/prefer-node-protocol\n} from 'buffer'\n\nexport {\n  Blob,\n  BlobOptions,\n  Buffer,\n  File,\n  FileOptions,\n  INSPECT_MAX_BYTES,\n  SlowBuffer,\n  TranscodeEncoding,\n  atob,\n  btoa,\n  constants,\n  isAscii,\n  isUtf8,\n  kMaxLength,\n  kStringMaxLength,\n  resolveObjectURL,\n  transcode,\n}\n\nexport default Buffer\n", "// eslint-disable-next-line @typescript-eslint/no-invalid-this\nconst global = globalThis || this || self\n\nexport { global }\nexport default global\n", "// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n", "/**\n * Internal webcrypto alias.\n * We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n * See utils.ts for details.\n * @module\n */\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto: any =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Asserts something is hash */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** @deprecated */\nexport const byteSwapIfBE: typeof swap8IfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = string | Uint8Array;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash interface. */\nexport type IHash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  abstract clone(): T;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash function */\nexport type CHash = ReturnType<typeof createHasher>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof createOptHasher>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof createXOFer>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function createOptHasher<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function createXOFer<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\nexport const wrapConstructor: typeof createHasher = createHasher;\nexport const wrapConstructorWithOpts: typeof createOptHasher = createOptHasher;\nexport const wrapXOFConstructorWithOpts: typeof createXOFer = createXOFer;\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return Uint8Array.from(crypto.randomBytes(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { type Input, Hash, abytes, aexists, aoutput, clean, createView, toBytes } from './utils.ts';\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n\n  readonly blockLen: number;\n  readonly outputLen: number;\n  readonly padOffset: number;\n  readonly isLE: boolean;\n\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { view, buffer, blockLen } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    clean(this.buffer.subarray(pos));\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n  0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n  0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n", "/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0; i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\nimport { type CHash, clean, createHasher, rotr } from './utils.ts';\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected A: number = SHA256_IV[0] | 0;\n  protected B: number = SHA256_IV[1] | 0;\n  protected C: number = SHA256_IV[2] | 0;\n  protected D: number = SHA256_IV[3] | 0;\n  protected E: number = SHA256_IV[4] | 0;\n  protected F: number = SHA256_IV[5] | 0;\n  protected G: number = SHA256_IV[6] | 0;\n  protected H: number = SHA256_IV[7] | 0;\n\n  constructor(outputLen: number = 32) {\n    super(64, outputLen, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean(): void {\n    clean(SHA256_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\nexport class SHA224 extends SHA256 {\n  protected A: number = SHA224_IV[0] | 0;\n  protected B: number = SHA224_IV[1] | 0;\n  protected C: number = SHA224_IV[2] | 0;\n  protected D: number = SHA224_IV[3] | 0;\n  protected E: number = SHA224_IV[4] | 0;\n  protected F: number = SHA224_IV[5] | 0;\n  protected G: number = SHA224_IV[6] | 0;\n  protected H: number = SHA224_IV[7] | 0;\n  constructor() {\n    super(28);\n  }\n}\n\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n\nexport class SHA512 extends HashMD<SHA512> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  // h -- high 32 bits, l -- low 32 bits\n  protected Ah: number = SHA512_IV[0] | 0;\n  protected Al: number = SHA512_IV[1] | 0;\n  protected Bh: number = SHA512_IV[2] | 0;\n  protected Bl: number = SHA512_IV[3] | 0;\n  protected Ch: number = SHA512_IV[4] | 0;\n  protected Cl: number = SHA512_IV[5] | 0;\n  protected Dh: number = SHA512_IV[6] | 0;\n  protected Dl: number = SHA512_IV[7] | 0;\n  protected Eh: number = SHA512_IV[8] | 0;\n  protected El: number = SHA512_IV[9] | 0;\n  protected Fh: number = SHA512_IV[10] | 0;\n  protected Fl: number = SHA512_IV[11] | 0;\n  protected Gh: number = SHA512_IV[12] | 0;\n  protected Gl: number = SHA512_IV[13] | 0;\n  protected Hh: number = SHA512_IV[14] | 0;\n  protected Hl: number = SHA512_IV[15] | 0;\n\n  constructor(outputLen: number = 64) {\n    super(128, outputLen, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ): void {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean(): void {\n    clean(SHA512_W_H, SHA512_W_L);\n  }\n  destroy(): void {\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\nexport class SHA384 extends SHA512 {\n  protected Ah: number = SHA384_IV[0] | 0;\n  protected Al: number = SHA384_IV[1] | 0;\n  protected Bh: number = SHA384_IV[2] | 0;\n  protected Bl: number = SHA384_IV[3] | 0;\n  protected Ch: number = SHA384_IV[4] | 0;\n  protected Cl: number = SHA384_IV[5] | 0;\n  protected Dh: number = SHA384_IV[6] | 0;\n  protected Dl: number = SHA384_IV[7] | 0;\n  protected Eh: number = SHA384_IV[8] | 0;\n  protected El: number = SHA384_IV[9] | 0;\n  protected Fh: number = SHA384_IV[10] | 0;\n  protected Fl: number = SHA384_IV[11] | 0;\n  protected Gh: number = SHA384_IV[12] | 0;\n  protected Gl: number = SHA384_IV[13] | 0;\n  protected Hh: number = SHA384_IV[14] | 0;\n  protected Hl: number = SHA384_IV[15] | 0;\n\n  constructor() {\n    super(48);\n  }\n}\n\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n  0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n  0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n  0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n  0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n\nexport class SHA512_224 extends SHA512 {\n  protected Ah: number = T224_IV[0] | 0;\n  protected Al: number = T224_IV[1] | 0;\n  protected Bh: number = T224_IV[2] | 0;\n  protected Bl: number = T224_IV[3] | 0;\n  protected Ch: number = T224_IV[4] | 0;\n  protected Cl: number = T224_IV[5] | 0;\n  protected Dh: number = T224_IV[6] | 0;\n  protected Dl: number = T224_IV[7] | 0;\n  protected Eh: number = T224_IV[8] | 0;\n  protected El: number = T224_IV[9] | 0;\n  protected Fh: number = T224_IV[10] | 0;\n  protected Fl: number = T224_IV[11] | 0;\n  protected Gh: number = T224_IV[12] | 0;\n  protected Gl: number = T224_IV[13] | 0;\n  protected Hh: number = T224_IV[14] | 0;\n  protected Hl: number = T224_IV[15] | 0;\n\n  constructor() {\n    super(28);\n  }\n}\n\nexport class SHA512_256 extends SHA512 {\n  protected Ah: number = T256_IV[0] | 0;\n  protected Al: number = T256_IV[1] | 0;\n  protected Bh: number = T256_IV[2] | 0;\n  protected Bl: number = T256_IV[3] | 0;\n  protected Ch: number = T256_IV[4] | 0;\n  protected Cl: number = T256_IV[5] | 0;\n  protected Dh: number = T256_IV[6] | 0;\n  protected Dl: number = T256_IV[7] | 0;\n  protected Eh: number = T256_IV[8] | 0;\n  protected El: number = T256_IV[9] | 0;\n  protected Fh: number = T256_IV[10] | 0;\n  protected Fl: number = T256_IV[11] | 0;\n  protected Gh: number = T256_IV[12] | 0;\n  protected Gl: number = T256_IV[13] | 0;\n  protected Hh: number = T256_IV[14] | 0;\n  protected Hl: number = T256_IV[15] | 0;\n\n  constructor() {\n    super(32);\n  }\n}\n\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexport const sha256: CHash = /* @__PURE__ */ createHasher(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224: CHash = /* @__PURE__ */ createHasher(() => new SHA224());\n\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512: CHash = /* @__PURE__ */ createHasher(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384: CHash = /* @__PURE__ */ createHasher(() => new SHA384());\n\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256: CHash = /* @__PURE__ */ createHasher(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224: CHash = /* @__PURE__ */ createHasher(() => new SHA512_224());\n", "/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  abytes as abytes_,\n  bytesToHex as bytesToHex_,\n  concatBytes as concatBytes_,\n  hexToBytes as hexToBytes_,\n  isBytes as isBytes_,\n} from '@noble/hashes/utils.js';\nexport {\n  abytes,\n  anumber,\n  bytesToHex,\n  bytesToUtf8,\n  concatBytes,\n  hexToBytes,\n  isBytes,\n  randomBytes,\n  utf8ToBytes,\n} from '@noble/hashes/utils.js';\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nexport function abool(title: string, value: boolean): void {\n  if (typeof value !== 'boolean') throw new Error(title + ' boolean expected, got ' + value);\n}\n\n// Used in weierstrass, der\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? '0' + hex : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex_(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  abytes_(bytes);\n  return hexToNumber(bytesToHex_(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes_(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes_(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes_(hex);\n    } catch (e) {\n      throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n    }\n  } else if (isBytes_(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(title + ' must be hex string or Uint8Array');\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n  return res;\n}\n\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\n// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\n// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;\n\n// Is positive bigint\nconst isPosBig = (n: bigint) => typeof n === 'bigint' && _0n <= n;\n\nexport function inRange(n: bigint, min: bigint, max: bigint): boolean {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title: string, n: bigint, min: bigint, max: bigint): void {\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n  // consider P=256n, min=0n, max=P\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\n  if (!inRange(n, min, max))\n    throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n: bigint): number {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number): bigint {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n: bigint, pos: number, value: boolean): bigint {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number): bigint => (_1n << BigInt(n)) - _1n;\n\n// DRBG\n\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  const u8n = (len: number) => new Uint8Array(len); // creates Uint8Array\n  const u8of = (byte: number) => Uint8Array.of(byte); // another shortcut\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n(0)) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes_(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any): boolean => typeof val === 'bigint',\n  function: (val: any): boolean => typeof val === 'function',\n  boolean: (val: any): boolean => typeof val === 'boolean',\n  string: (val: any): boolean => typeof val === 'string',\n  stringOrUint8Array: (val: any): boolean => typeof val === 'string' || isBytes_(val),\n  isSafeInteger: (val: any): boolean => Number.isSafeInteger(val),\n  array: (val: any): boolean => Array.isArray(val),\n  field: (val: any, object: any): any => (object as any).Fp.isValid(val),\n  hash: (val: any): boolean => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n): T {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error('invalid validator function');\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        'param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n\nexport function isHash(val: CHash): boolean {\n  return typeof val === 'function' && Number.isSafeInteger(val.outputLen);\n}\nexport function _validateObject(\n  object: Record<string, any>,\n  fields: Record<string, string>,\n  optFields: Record<string, string> = {}\n): void {\n  if (!object || typeof object !== 'object') throw new Error('expected valid options object');\n  type Item = keyof typeof object;\n  function checkField(fieldName: Item, expectedType: string, isOpt: boolean) {\n    const val = object[fieldName];\n    if (isOpt && val === undefined) return;\n    const current = typeof val;\n    if (current !== expectedType || val === null)\n      throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n  }\n  Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));\n  Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));\n}\n\n/**\n * throws not implemented error\n */\nexport const notImplemented = (): never => {\n  throw new Error('not implemented');\n};\n\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized<T extends object, R, O extends any[]>(\n  fn: (arg: T, ...args: O) => R\n): (arg: T, ...args: O) => R {\n  const map = new WeakMap<T, R>();\n  return (arg: T, ...args: O): R => {\n    const val = map.get(arg);\n    if (val !== undefined) return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}\n", "/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  _validateObject,\n  anumber,\n  bitMask,\n  bytesToNumberBE,\n  bytesToNumberLE,\n  ensureBytes,\n  numberToBytesBE,\n  numberToBytesLE,\n} from '../utils.ts';\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5);\nconst _8n = /* @__PURE__ */ BigInt(8);\n\n// Calculates a modulo b\nexport function mod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\n  return FpPow(Field(modulo), num, power);\n}\n\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number: bigint, modulo: bigint): bigint {\n  if (number === _0n) throw new Error('invert: expected non-zero number');\n  if (modulo <= _0n) throw new Error('invert: expected positive modulus, got ' + modulo);\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n, y = _1n, u = _1n, v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4<T>(Fp: IField<T>, n: T) {\n  const p1div4 = (Fp.ORDER + _1n) / _4n;\n  const root = Fp.pow(n, p1div4);\n  // Throw if root^2 != n\n  if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n  return root;\n}\n\nfunction sqrt5mod8<T>(Fp: IField<T>, n: T) {\n  const p5div8 = (Fp.ORDER - _5n) / _8n;\n  const n2 = Fp.mul(n, _2n);\n  const v = Fp.pow(n2, p5div8);\n  const nv = Fp.mul(n, v);\n  const i = Fp.mul(Fp.mul(nv, _2n), v);\n  const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n  if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n  return root;\n}\n\n// TODO: Commented-out for now. Provide test vectors.\n// Tonelli is too slow for extension fields Fp2.\n// That means we can't use sqrt (c1, c2...) even for initialization constants.\n// if (P % _16n === _9n) return sqrt9mod16;\n// // prettier-ignore\n// function sqrt9mod16<T>(Fp: IField<T>, n: T, p7div16?: bigint) {\n//   if (p7div16 === undefined) p7div16 = (Fp.ORDER + BigInt(7)) / _16n;\n//   const c1 = Fp.sqrt(Fp.neg(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n//   const c2 = Fp.sqrt(c1);             //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n//   const c3 = Fp.sqrt(Fp.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n//   const c4 = p7div16;                 //  4. c4 = (q + 7) / 16        # Integer arithmetic\n//   let tv1 = Fp.pow(n, c4);            //  1. tv1 = x^c4\n//   let tv2 = Fp.mul(c1, tv1);          //  2. tv2 = c1 * tv1\n//   const tv3 = Fp.mul(c2, tv1);        //  3. tv3 = c2 * tv1\n//   let tv4 = Fp.mul(c3, tv1);          //  4. tv4 = c3 * tv1\n//   const e1 = Fp.eql(Fp.sqr(tv2), n);  //  5.  e1 = (tv2^2) == x\n//   const e2 = Fp.eql(Fp.sqr(tv3), n);  //  6.  e2 = (tv3^2) == x\n//   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n//   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n//   const e3 = Fp.eql(Fp.sqr(tv2), n);  //  9.  e3 = (tv2^2) == x\n//   return Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3) # Select the sqrt from tv1 and tv2\n// }\n\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // Initialization (precomputation).\n  // Caching initialization could boost perf by 7%.\n  if (P < BigInt(3)) throw new Error('sqrt is not defined for small field');\n  // Factor P - 1 = Q * 2^S, where Q is odd\n  let Q = P - _1n;\n  let S = 0;\n  while (Q % _2n === _0n) {\n    Q /= _2n;\n    S++;\n  }\n\n  // Find the first quadratic non-residue Z >= 2\n  let Z = _2n;\n  const _Fp = Field(P);\n  while (FpLegendre(_Fp, Z) === 1) {\n    // Basic primality test for P. After x iterations, chance of\n    // not finding quadratic non-residue is 2^x, so 2^1000.\n    if (Z++ > 1000) throw new Error('Cannot find square root: probably non-prime P');\n  }\n  // Fast-path; usually done before Z, but we do \"primality test\".\n  if (S === 1) return sqrt3mod4;\n\n  // Slow-path\n  // TODO: test on Fp2 and others\n  let cc = _Fp.pow(Z, Q); // c = z^Q\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\n    if (Fp.is0(n)) return n;\n    // Check if n is a quadratic residue using Legendre symbol\n    if (FpLegendre(Fp, n) !== 1) throw new Error('Cannot find square root');\n\n    // Initialize variables for the main loop\n    let M = S;\n    let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n    let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n    let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n\n    // Main loop\n    // while t != 1\n    while (!Fp.eql(t, Fp.ONE)) {\n      if (Fp.is0(t)) return Fp.ZERO; // if t=0 return R=0\n      let i = 1;\n\n      // Find the smallest i >= 1 such that t^(2^i) ≡ 1 (mod P)\n      let t_tmp = Fp.sqr(t); // t^(2^1)\n      while (!Fp.eql(t_tmp, Fp.ONE)) {\n        i++;\n        t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n        if (i === M) throw new Error('Cannot find square root');\n      }\n\n      // Calculate the exponent for b: 2^(M - i - 1)\n      const exponent = _1n << BigInt(M - i - 1); // bigint is important\n      const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n\n      // Update variables\n      M = i;\n      c = Fp.sqr(b); // c = b^2\n      t = Fp.mul(t, c); // t = (t * b^2)\n      R = Fp.mul(R, b); // R = R*b\n    }\n    return R;\n  };\n}\n\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P ≡ 3 (mod 4)\n * 2. P ≡ 5 (mod 8)\n * 3. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // P ≡ 3 (mod 4) => √n = n^((P+1)/4)\n  if (P % _4n === _3n) return sqrt3mod4;\n  // P ≡ 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n  if (P % _8n === _5n) return sqrt5mod8;\n  // P ≡ 9 (mod 16) not implemented, see above\n  // Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num: bigint, modulo: bigint): boolean =>\n  (mod(num, modulo) & _1n) === _1n;\n\n/** Field is not always over prime: for example, Fp2 has ORDER(q)=p^m. */\nexport interface IField<T> {\n  ORDER: bigint;\n  isLE: boolean;\n  BYTES: number;\n  BITS: number;\n  MASK: bigint;\n  ZERO: T;\n  ONE: T;\n  // 1-arg\n  create: (num: T) => T;\n  isValid: (num: T) => boolean;\n  is0: (num: T) => boolean;\n  isValidNot0: (num: T) => boolean;\n  neg(num: T): T;\n  inv(num: T): T;\n  sqrt(num: T): T;\n  sqr(num: T): T;\n  // 2-args\n  eql(lhs: T, rhs: T): boolean;\n  add(lhs: T, rhs: T): T;\n  sub(lhs: T, rhs: T): T;\n  mul(lhs: T, rhs: T | bigint): T;\n  pow(lhs: T, power: bigint): T;\n  div(lhs: T, rhs: T | bigint): T;\n  // N for NonNormalized (for now)\n  addN(lhs: T, rhs: T): T;\n  subN(lhs: T, rhs: T): T;\n  mulN(lhs: T, rhs: T | bigint): T;\n  sqrN(num: T): T;\n\n  // Optional\n  // Should be same as sgn0 function in\n  // [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#section-4.1).\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\n  // legendre?(num: T): T;\n  invertBatch: (lst: T[]) => T[];\n  toBytes(num: T): Uint8Array;\n  fromBytes(bytes: Uint8Array): T;\n  // If c is False, CMOV returns a, otherwise it returns b.\n  cmov(a: T, b: T, c: boolean): T;\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\n  'addN', 'subN', 'mulN', 'sqrN'\n] as const;\nexport function validateField<T>(field: IField<T>): IField<T> {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'number',\n    BITS: 'number',\n  } as Record<string, string>;\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  _validateObject(field, opts);\n  // const max = 16384;\n  // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n  // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n  return field;\n}\n\n// Generic field functions\n\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow<T>(Fp: IField<T>, num: T, power: bigint): T {\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (power === _0n) return Fp.ONE;\n  if (power === _1n) return num;\n  let p = Fp.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = Fp.mul(p, d);\n    d = Fp.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nexport function FpInvertBatch<T>(Fp: IField<T>, nums: T[], passZero = false): T[] {\n  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n  // Walk from first to last, multiply them by each other MOD p\n  const multipliedAcc = nums.reduce((acc, num, i) => {\n    if (Fp.is0(num)) return acc;\n    inverted[i] = acc;\n    return Fp.mul(acc, num);\n  }, Fp.ONE);\n  // Invert last element\n  const invertedAcc = Fp.inv(multipliedAcc);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (Fp.is0(num)) return acc;\n    inverted[i] = Fp.mul(acc, inverted[i]);\n    return Fp.mul(acc, num);\n  }, invertedAcc);\n  return inverted;\n}\n\n// TODO: remove\nexport function FpDiv<T>(Fp: IField<T>, lhs: T, rhs: T | bigint): T {\n  return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p) ≡ 1    if a is a square (mod p), quadratic residue\n * * (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ≡ 0    if a ≡ 0 (mod p)\n */\nexport function FpLegendre<T>(Fp: IField<T>, n: T): -1 | 0 | 1 {\n  // We can use 3rd argument as optional cache of this value\n  // but seems unneeded for now. The operation is very fast.\n  const p1mod2 = (Fp.ORDER - _1n) / _2n;\n  const powered = Fp.pow(n, p1mod2);\n  const yes = Fp.eql(powered, Fp.ONE);\n  const zero = Fp.eql(powered, Fp.ZERO);\n  const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n  if (!yes && !zero && !no) throw new Error('invalid Legendre symbol result');\n  return yes ? 1 : zero ? 0 : -1;\n}\n\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare<T>(Fp: IField<T>, n: T): boolean {\n  const l = FpLegendre(Fp, n);\n  return l === 1;\n}\n\nexport type NLength = { nByteLength: number; nBitLength: number };\n// CURVE.n lengths\nexport function nLength(n: bigint, nBitLength?: number): NLength {\n  // Bit size, byte size of CURVE.n\n  if (nBitLength !== undefined) anumber(nBitLength);\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\ntype SqrtFn = (n: bigint) => bigint;\ntype FieldOpts = Partial<{ sqrt: SqrtFn; isLE: boolean; BITS: number }>;\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(\n  ORDER: bigint,\n  bitLenOrOpts?: number | FieldOpts,\n  isLE = false,\n  opts: { sqrt?: SqrtFn } = {}\n): Readonly<FpField> {\n  if (ORDER <= _0n) throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n  let _nbitLength: number | undefined = undefined;\n  let _sqrt: SqrtFn | undefined = undefined;\n  if (typeof bitLenOrOpts === 'object' && bitLenOrOpts != null) {\n    if (opts.sqrt || isLE) throw new Error('cannot specify opts in two arguments');\n    const _opts = bitLenOrOpts;\n    if (_opts.BITS) _nbitLength = _opts.BITS;\n    if (_opts.sqrt) _sqrt = _opts.sqrt;\n    if (typeof _opts.isLE === 'boolean') isLE = _opts.isLE;\n  } else {\n    if (typeof bitLenOrOpts === 'number') _nbitLength = bitLenOrOpts;\n    if (opts.sqrt) _sqrt = opts.sqrt;\n  }\n  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);\n  if (BYTES > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n  let sqrtP: ReturnType<typeof FpSqrt>; // cached sqrtP\n  const f: Readonly<FpField> = Object.freeze({\n    ORDER,\n    isLE,\n    BITS,\n    BYTES,\n    MASK: bitMask(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    create: (num) => mod(num, ORDER),\n    isValid: (num) => {\n      if (typeof num !== 'bigint')\n        throw new Error('invalid field element: expected bigint, got ' + typeof num);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: (num) => num === _0n,\n    // is valid and invertible\n    isValidNot0: (num: bigint) => !f.is0(num) && f.isValid(num),\n    isOdd: (num) => (num & _1n) === _1n,\n    neg: (num) => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n\n    sqr: (num) => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n\n    // Same as above, but doesn't normalize\n    sqrN: (num) => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n\n    inv: (num) => invert(num, ORDER),\n    sqrt:\n      _sqrt ||\n      ((n) => {\n        if (!sqrtP) sqrtP = FpSqrt(ORDER);\n        return sqrtP(f, n);\n      }),\n    toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n    fromBytes: (bytes) => {\n      if (bytes.length !== BYTES)\n        throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n    },\n    // TODO: we don't need it here, move out to separate fn\n    invertBatch: (lst) => FpInvertBatch(f, lst),\n    // We can't move this out because Fp6, Fp12 implement it\n    // and it's unclear what to return in there.\n    cmov: (a, b, c) => (c ? b : a),\n  } as FpField);\n  return Object.freeze(f);\n}\n\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nexport function hashToPrivateScalar(\n  hash: string | Uint8Array,\n  groupOrder: bigint,\n  isLE = false\n): bigint {\n  hash = ensureBytes('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n    throw new Error(\n      'hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen\n    );\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder: bigint): number {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder: bigint): number {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE = false): Uint8Array {\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024)\n    throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n  const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n", "/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { bitLen, bitMask, validateObject } from '../utils.ts';\nimport { Field, FpInvertBatch, type IField, nLength, validateField } from './modular.ts';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n\nexport type AffinePoint<T> = {\n  x: T;\n  y: T;\n} & { z?: never; t?: never };\n\nexport interface Group<T extends Group<T>> {\n  double(): T;\n  negate(): T;\n  add(other: T): T;\n  subtract(other: T): T;\n  equals(other: T): boolean;\n  multiply(scalar: bigint): T;\n  toAffine?(invertedZ?: any): AffinePoint<any>;\n}\n\nexport type GroupConstructor<T> = {\n  BASE: T;\n  ZERO: T;\n};\nexport type ExtendedGroupConstructor<T> = GroupConstructor<T> & {\n  Fp: IField<any>;\n  Fn: IField<bigint>;\n  fromAffine(ap: AffinePoint<any>): T;\n};\nexport type Mapper<T> = (i: T[]) => T[];\n\nexport function negateCt<T extends Group<T>>(condition: boolean, item: T): T {\n  const neg = item.negate();\n  return condition ? neg : item;\n}\n\n/**\n * Takes a bunch of Projective Points but executes only one\n * inversion on all of them. Inversion is very slow operation,\n * so this improves performance massively.\n * Optimization: converts a list of projective points to a list of identical points with Z=1.\n */\nexport function normalizeZ<T>(\n  c: ExtendedGroupConstructor<T>,\n  property: 'pz' | 'ez',\n  points: T[]\n): T[] {\n  const getz = property === 'pz' ? (p: any) => p.pz : (p: any) => p.ez;\n  const toInv = FpInvertBatch(c.Fp, points.map(getz));\n  // @ts-ignore\n  const affined = points.map((p, i) => p.toAffine(toInv[i]));\n  return affined.map(c.fromAffine);\n}\n\nfunction validateW(W: number, bits: number) {\n  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n    throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\n\n/** Internal wNAF opts for specific W and scalarBits */\nexport type WOpts = {\n  windows: number;\n  windowSize: number;\n  mask: bigint;\n  maxNumber: number;\n  shiftBy: bigint;\n};\n\nfunction calcWOpts(W: number, scalarBits: number): WOpts {\n  validateW(W, scalarBits);\n  const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n  const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n  const maxNumber = 2 ** W; // W=8 256\n  const mask = bitMask(W); // W=8 255 == mask 0b11111111\n  const shiftBy = BigInt(W); // W=8 8\n  return { windows, windowSize, mask, maxNumber, shiftBy };\n}\n\nfunction calcOffsets(n: bigint, window: number, wOpts: WOpts) {\n  const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n  let wbits = Number(n & mask); // extract W bits.\n  let nextN = n >> shiftBy; // shift number by W bits.\n\n  // What actually happens here:\n  // const highestBit = Number(mask ^ (mask >> 1n));\n  // let wbits2 = wbits - 1; // skip zero\n  // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n\n  // split if bits > max: +224 => 256-32\n  if (wbits > windowSize) {\n    // we skip zero, which means instead of `>= size-1`, we do `> size`\n    wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n    nextN += _1n; // +256 (carry)\n  }\n  const offsetStart = window * windowSize;\n  const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n  const isZero = wbits === 0; // is current window slice a 0?\n  const isNeg = wbits < 0; // is current window slice negative?\n  const isNegF = window % 2 !== 0; // fake random statement for noise\n  const offsetF = offsetStart; // fake offset for noise\n  return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\n\nfunction validateMSMPoints(points: any[], c: any) {\n  if (!Array.isArray(points)) throw new Error('array expected');\n  points.forEach((p, i) => {\n    if (!(p instanceof c)) throw new Error('invalid point at index ' + i);\n  });\n}\nfunction validateMSMScalars(scalars: any[], field: any) {\n  if (!Array.isArray(scalars)) throw new Error('array of scalars expected');\n  scalars.forEach((s, i) => {\n    if (!field.isValid(s)) throw new Error('invalid scalar at index ' + i);\n  });\n}\n\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap<any, any[]>();\nconst pointWindowSizes = new WeakMap<any, number>();\n\nfunction getW(P: any): number {\n  return pointWindowSizes.get(P) || 1;\n}\n\nfunction assert0(n: bigint): void {\n  if (n !== _0n) throw new Error('invalid wNAF');\n}\n\nexport type IWNAF<T extends Group<T>> = {\n  constTimeNegate: <T extends Group<T>>(condition: boolean, item: T) => T;\n  hasPrecomputes(elm: T): boolean;\n  unsafeLadder(elm: T, n: bigint, p?: T): T;\n  precomputeWindow(elm: T, W: number): Group<T>[];\n  getPrecomputes(W: number, P: T, transform?: Mapper<T>): T[];\n  wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T };\n  wNAFUnsafe(W: number, precomputes: T[], n: bigint, acc?: T): T;\n  wNAFCached(P: T, n: bigint, transform?: Mapper<T>): { p: T; f: T };\n  wNAFCachedUnsafe(P: T, n: bigint, transform?: Mapper<T>, prev?: T): T;\n  setWindowSize(P: T, W: number): void;\n};\n\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport function wNAF<T extends Group<T>>(c: GroupConstructor<T>, bits: number): IWNAF<T> {\n  return {\n    constTimeNegate: negateCt,\n\n    hasPrecomputes(elm: T) {\n      return getW(elm) !== 1;\n    },\n\n    // non-const time multiplication ladder\n    unsafeLadder(elm: T, n: bigint, p = c.ZERO) {\n      let d: T = elm;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    },\n\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n     * - 𝑊 is the window size\n     * - 𝑛 is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param elm Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(elm: T, W: number): Group<T>[] {\n      const { windows, windowSize } = calcWOpts(W, bits);\n      const points: T[] = [];\n      let p: T = elm;\n      let base = p;\n      for (let window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        // i=1, bc we skip 0\n        for (let i = 1; i < windowSize; i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    },\n\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T } {\n      // Smaller version:\n      // https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n      // TODO: check the scalar is less than group order?\n      // wNAF behavior is undefined otherwise. But have to carefully remove\n      // other checks before wNAF. ORDER == bits here.\n      // Accumulators\n      let p = c.ZERO;\n      let f = c.BASE;\n      // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n      // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n      // there is negate now: it is possible that negated element from low value\n      // would be the same as high element, which will create carry into next window.\n      // It's not obvious how this can fail, but still worth investigating later.\n      const wo = calcWOpts(W, bits);\n      for (let window = 0; window < wo.windows; window++) {\n        // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n        const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n        n = nextN;\n        if (isZero) {\n          // bits are 0: add garbage to fake point\n          // Important part for const-time getPublicKey: add random \"noise\" point to f.\n          f = f.add(negateCt(isNegF, precomputes[offsetF]));\n        } else {\n          // bits are 1: add to result point\n          p = p.add(negateCt(isNeg, precomputes[offset]));\n        }\n      }\n      assert0(n);\n      // Return both real and fake points: JIT won't eliminate f.\n      // At this point there is a way to F be infinity-point even if p is not,\n      // which makes it less const-time: around 1 bigint multiply.\n      return { p, f };\n    },\n\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */\n    wNAFUnsafe(W: number, precomputes: T[], n: bigint, acc: T = c.ZERO): T {\n      const wo = calcWOpts(W, bits);\n      for (let window = 0; window < wo.windows; window++) {\n        if (n === _0n) break; // Early-exit, skip 0 value\n        const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n        n = nextN;\n        if (isZero) {\n          // Window bits are 0: skip processing.\n          // Move to next window.\n          continue;\n        } else {\n          const item = precomputes[offset];\n          acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n        }\n      }\n      assert0(n);\n      return acc;\n    },\n\n    getPrecomputes(W: number, P: T, transform?: Mapper<T>): T[] {\n      // Calculate precomputes on a first run, reuse them after\n      let comp = pointPrecomputes.get(P);\n      if (!comp) {\n        comp = this.precomputeWindow(P, W) as T[];\n        if (W !== 1) {\n          // Doing transform outside of if brings 15% perf hit\n          if (typeof transform === 'function') comp = transform(comp);\n          pointPrecomputes.set(P, comp);\n        }\n      }\n      return comp;\n    },\n\n    wNAFCached(P: T, n: bigint, transform?: Mapper<T>): { p: T; f: T } {\n      const W = getW(P);\n      return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n    },\n\n    wNAFCachedUnsafe(P: T, n: bigint, transform?: Mapper<T>, prev?: T): T {\n      const W = getW(P);\n      if (W === 1) return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n      return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n    },\n\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n\n    setWindowSize(P: T, W: number) {\n      validateW(W, bits);\n      pointWindowSizes.set(P, W);\n      pointPrecomputes.delete(P);\n    },\n  };\n}\n\n/**\n * Endomorphism-specific multiplication for Koblitz curves.\n * Cost: 128 dbl, 0-256 adds.\n */\nexport function mulEndoUnsafe<T extends Group<T>>(\n  c: GroupConstructor<T>,\n  point: T,\n  k1: bigint,\n  k2: bigint\n): { p1: T; p2: T } {\n  let acc = point;\n  let p1 = c.ZERO;\n  let p2 = c.ZERO;\n  while (k1 > _0n || k2 > _0n) {\n    if (k1 & _1n) p1 = p1.add(acc);\n    if (k2 & _1n) p2 = p2.add(acc);\n    acc = acc.double();\n    k1 >>= _1n;\n    k2 >>= _1n;\n  }\n  return { p1, p2 };\n}\n\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nexport function pippenger<T extends Group<T>>(\n  c: GroupConstructor<T>,\n  fieldN: IField<bigint>,\n  points: T[],\n  scalars: bigint[]\n): T {\n  // If we split scalars by some window (let's say 8 bits), every chunk will only\n  // take 256 buckets even if there are 4096 scalars, also re-uses double.\n  // TODO:\n  // - https://eprint.iacr.org/2024/750.pdf\n  // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n  // 0 is accepted in scalars\n  validateMSMPoints(points, c);\n  validateMSMScalars(scalars, fieldN);\n  const plength = points.length;\n  const slength = scalars.length;\n  if (plength !== slength) throw new Error('arrays of points and scalars must have equal length');\n  // if (plength === 0) throw new Error('array must be of length >= 2');\n  const zero = c.ZERO;\n  const wbits = bitLen(BigInt(plength));\n  let windowSize = 1; // bits\n  if (wbits > 12) windowSize = wbits - 3;\n  else if (wbits > 4) windowSize = wbits - 2;\n  else if (wbits > 0) windowSize = 2;\n  const MASK = bitMask(windowSize);\n  const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n  let sum = zero;\n  for (let i = lastBits; i >= 0; i -= windowSize) {\n    buckets.fill(zero);\n    for (let j = 0; j < slength; j++) {\n      const scalar = scalars[j];\n      const wbits = Number((scalar >> BigInt(i)) & MASK);\n      buckets[wbits] = buckets[wbits].add(points[j]);\n    }\n    let resI = zero; // not using this will do small speed-up, but will lose ct\n    // Skip first bucket, because it is zero\n    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n      sumI = sumI.add(buckets[j]);\n      resI = resI.add(sumI);\n    }\n    sum = sum.add(resI);\n    if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();\n  }\n  return sum as T;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe<T extends Group<T>>(\n  c: GroupConstructor<T>,\n  fieldN: IField<bigint>,\n  points: T[],\n  windowSize: number\n): (scalars: bigint[]) => T {\n  /**\n   * Performance Analysis of Window-based Precomputation\n   *\n   * Base Case (256-bit scalar, 8-bit window):\n   * - Standard precomputation requires:\n   *   - 31 additions per scalar × 256 scalars = 7,936 ops\n   *   - Plus 255 summary additions = 8,191 total ops\n   *   Note: Summary additions can be optimized via accumulator\n   *\n   * Chunked Precomputation Analysis:\n   * - Using 32 chunks requires:\n   *   - 255 additions per chunk\n   *   - 256 doublings\n   *   - Total: (255 × 32) + 256 = 8,416 ops\n   *\n   * Memory Usage Comparison:\n   * Window Size | Standard Points | Chunked Points\n   * ------------|-----------------|---------------\n   *     4-bit   |     520         |      15\n   *     8-bit   |    4,224        |     255\n   *    10-bit   |   13,824        |   1,023\n   *    16-bit   |  557,056        |  65,535\n   *\n   * Key Advantages:\n   * 1. Enables larger window sizes due to reduced memory overhead\n   * 2. More efficient for smaller scalar counts:\n   *    - 16 chunks: (16 × 255) + 256 = 4,336 ops\n   *    - ~2x faster than standard 8,191 ops\n   *\n   * Limitations:\n   * - Not suitable for plain precomputes (requires 256 constant doublings)\n   * - Performance degrades with larger scalar counts:\n   *   - Optimal for ~256 scalars\n   *   - Less efficient for 4096+ scalars (Pippenger preferred)\n   */\n  validateW(windowSize, fieldN.BITS);\n  validateMSMPoints(points, c);\n  const zero = c.ZERO;\n  const tableSize = 2 ** windowSize - 1; // table size (without zero)\n  const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n  const MASK = bitMask(windowSize);\n  const tables = points.map((p: T) => {\n    const res = [];\n    for (let i = 0, acc = p; i < tableSize; i++) {\n      res.push(acc);\n      acc = acc.add(p);\n    }\n    return res;\n  });\n  return (scalars: bigint[]): T => {\n    validateMSMScalars(scalars, fieldN);\n    if (scalars.length > points.length)\n      throw new Error('array of scalars must be smaller than array of points');\n    let res = zero;\n    for (let i = 0; i < chunks; i++) {\n      // No need to double if accumulator is still zero.\n      if (res !== zero) for (let j = 0; j < windowSize; j++) res = res.double();\n      const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n      for (let j = 0; j < scalars.length; j++) {\n        const n = scalars[j];\n        const curr = Number((n >> shiftBy) & MASK);\n        if (!curr) continue; // skip zero scalars chunks\n        res = res.add(tables[j][curr - 1]);\n      }\n    }\n    return res;\n  };\n}\n\n/**\n * Generic BasicCurve interface: works even for polynomial fields (BLS): P, n, h would be ok.\n * Though generator can be different (Fp2 / Fp6 for BLS).\n */\nexport type BasicCurve<T> = {\n  Fp: IField<T>; // Field over which we'll do calculations (Fp)\n  n: bigint; // Curve order, total count of valid points in the field\n  nBitLength?: number; // bit length of curve order\n  nByteLength?: number; // byte length of curve order\n  h: bigint; // cofactor. we can assign default=1, but users will just ignore it w/o validation\n  hEff?: bigint; // Number to multiply to clear cofactor\n  Gx: T; // base point X coordinate\n  Gy: T; // base point Y coordinate\n  allowInfinityPoint?: boolean; // bls12-381 requires it. ZERO point is valid, but invalid pubkey\n};\n\n// TODO: remove\n/** @deprecated */\nexport function validateBasic<FP, T>(\n  curve: BasicCurve<FP> & T\n): Readonly<\n  {\n    readonly nBitLength: number;\n    readonly nByteLength: number;\n  } & BasicCurve<FP> &\n    T & {\n      p: bigint;\n    }\n> {\n  validateField(curve.Fp);\n  validateObject(\n    curve,\n    {\n      n: 'bigint',\n      h: 'bigint',\n      Gx: 'field',\n      Gy: 'field',\n    },\n    {\n      nBitLength: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n    }\n  );\n  // Set defaults\n  return Object.freeze({\n    ...nLength(curve.n, curve.nBitLength),\n    ...curve,\n    ...{ p: curve.Fp.ORDER },\n  } as const);\n}\n\nexport type ValidCurveParams<T> = {\n  a: T;\n  p: bigint;\n  n: bigint;\n  h: bigint;\n  Gx: T;\n  Gy: T;\n} & ({ b: T } | { d: T });\n\nfunction createField<T>(order: bigint, field?: IField<T>): IField<T> {\n  if (field) {\n    if (field.ORDER !== order) throw new Error('Field.ORDER must match order: Fp == p, Fn == n');\n    validateField(field);\n    return field;\n  } else {\n    return Field(order) as unknown as IField<T>;\n  }\n}\nexport type FpFn<T> = { Fp: IField<T>; Fn: IField<bigint> };\n/** Validates CURVE opts and creates fields */\nexport function _createCurveFields<T>(\n  type: 'weierstrass' | 'edwards',\n  CURVE: ValidCurveParams<T>,\n  curveOpts: Partial<FpFn<T>> = {}\n): FpFn<T> {\n  if (!CURVE || typeof CURVE !== 'object') throw new Error(`expected valid ${type} CURVE object`);\n  for (const p of ['p', 'n', 'h'] as const) {\n    const val = CURVE[p];\n    if (!(typeof val === 'bigint' && val > _0n))\n      throw new Error(`CURVE.${p} must be positive bigint`);\n  }\n  const Fp = createField(CURVE.p, curveOpts.Fp);\n  const Fn = createField(CURVE.n, curveOpts.Fn);\n  const _b: 'b' | 'd' = type === 'weierstrass' ? 'b' : 'd';\n  const params = ['Gx', 'Gy', 'a', _b] as const;\n  for (const p of params) {\n    // @ts-ignore\n    if (!Fp.isValid(CURVE[p]))\n      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n  }\n  return { Fp, Fn };\n}\n", "/**\n * Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y².\n * For design rationale of types / exports, see weierstrass module documentation.\n * Untwisted Edwards curves exist, but they aren't used in real-world protocols.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  _validateObject,\n  abool,\n  abytes,\n  aInRange,\n  bytesToHex,\n  bytesToNumberLE,\n  concatBytes,\n  ensureBytes,\n  memoized,\n  numberToBytesLE,\n  randomBytes,\n  type FHash,\n  type Hex,\n} from '../utils.ts';\nimport {\n  _createCurveFields,\n  normalizeZ,\n  pippenger,\n  wNAF,\n  type AffinePoint,\n  type BasicCurve,\n  type Group,\n  type GroupConstructor,\n} from './curve.ts';\nimport { Field, type IField, type NLength } from './modular.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n\nexport type UVRatio = (u: bigint, v: bigint) => { isValid: boolean; value: bigint };\n\n/** Edwards curves must declare params a & d. */\nexport type CurveType = BasicCurve<bigint> & {\n  a: bigint; // curve param a\n  d: bigint; // curve param d\n  hash: FHash; // Hashing\n  randomBytes?: (bytesLength?: number) => Uint8Array; // CSPRNG\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array; // clears bits to get valid field elemtn\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array; // Used for hashing\n  uvRatio?: UVRatio; // Ratio √(u/v)\n  prehash?: FHash; // RFC 8032 pre-hashing of messages to sign() / verify()\n  mapToCurve?: (scalar: bigint[]) => AffinePoint<bigint>; // for hash-to-curve standard\n};\n\nexport type CurveTypeWithLength = Readonly<CurveType & Partial<NLength>>;\n\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\n\n/** Instance of Extended Point with coordinates in X, Y, Z, T. */\nexport interface ExtPointType extends Group<ExtPointType> {\n  readonly ex: bigint;\n  readonly ey: bigint;\n  readonly ez: bigint;\n  readonly et: bigint;\n  get x(): bigint;\n  get y(): bigint;\n  assertValidity(): void;\n  multiply(scalar: bigint): ExtPointType;\n  multiplyUnsafe(scalar: bigint): ExtPointType;\n  is0(): boolean;\n  isSmallOrder(): boolean;\n  isTorsionFree(): boolean;\n  clearCofactor(): ExtPointType;\n  toAffine(iz?: bigint): AffinePoint<bigint>;\n  toBytes(): Uint8Array;\n  /** @deprecated use `toBytes` */\n  toRawBytes(): Uint8Array;\n  toHex(): string;\n  precompute(windowSize?: number, isLazy?: boolean): ExtPointType;\n  /** @deprecated use `p.precompute(windowSize)` */\n  _setWindowSize(windowSize: number): void;\n}\n/** Static methods of Extended Point with coordinates in X, Y, Z, T. */\nexport interface ExtPointConstructor extends GroupConstructor<ExtPointType> {\n  new (x: bigint, y: bigint, z: bigint, t: bigint): ExtPointType;\n  Fp: IField<bigint>;\n  Fn: IField<bigint>;\n  fromAffine(p: AffinePoint<bigint>): ExtPointType;\n  fromBytes(bytes: Uint8Array, zip215?: boolean): ExtPointType;\n  fromHex(hex: Hex, zip215?: boolean): ExtPointType;\n  msm(points: ExtPointType[], scalars: bigint[]): ExtPointType;\n}\n\n/**\n * Twisted Edwards curve options.\n *\n * * a: formula param\n * * d: formula param\n * * p: prime characteristic (order) of finite field, in which arithmetics is done\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * h: cofactor. h*n is group order; n is subgroup order\n * * Gx: x coordinate of generator point a.k.a. base point\n * * Gy: y coordinate of generator point\n */\nexport type EdwardsOpts = Readonly<{\n  a: bigint;\n  d: bigint;\n  p: bigint;\n  n: bigint;\n  h: bigint;\n  Gx: bigint;\n  Gy: bigint;\n}>;\n\n/**\n * Extra curve options for Twisted Edwards.\n *\n * * Fp: redefined Field over curve.p\n * * Fn: redefined Field over curve.n\n * * uvRatio: helper function for decompression, calculating √(u/v)\n */\nexport type EdwardsExtraOpts = Partial<{\n  Fp: IField<bigint>;\n  Fn: IField<bigint>;\n  uvRatio: (u: bigint, v: bigint) => { isValid: boolean; value: bigint };\n}>;\n\n/**\n * EdDSA (Edwards Digital Signature algorithm) options.\n *\n * * hash: hash function used to hash private keys and messages\n * * adjustScalarBytes: clears bits to get valid field element\n * * domain: Used for hashing\n * * mapToCurve: for hash-to-curve standard\n * * prehash: RFC 8032 pre-hashing of messages to sign() / verify()\n * * randomBytes: function generating random bytes, used for randomPrivateKey\n */\nexport type EdDSAOpts = {\n  hash: FHash;\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array;\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array;\n  mapToCurve?: (scalar: bigint[]) => AffinePoint<bigint>;\n  prehash?: FHash;\n  randomBytes?: (bytesLength?: number) => Uint8Array;\n};\n\n/**\n * EdDSA (Edwards Digital Signature algorithm) interface.\n *\n * Allows to create and verify signatures, create public and private keys.\n */\nexport interface EdDSA {\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  sign: (message: Hex, privateKey: Hex, options?: { context?: Hex }) => Uint8Array;\n  verify: (\n    sig: Hex,\n    message: Hex,\n    publicKey: Hex,\n    options?: { context?: Hex; zip215: boolean }\n  ) => boolean;\n  Point: ExtPointConstructor;\n  utils: {\n    randomPrivateKey: () => Uint8Array;\n    getExtendedPublicKey: (key: Hex) => {\n      head: Uint8Array;\n      prefix: Uint8Array;\n      scalar: bigint;\n      point: ExtPointType;\n      pointBytes: Uint8Array;\n    };\n    /** @deprecated use `point.precompute()` */\n    precompute: (windowSize?: number, point?: ExtPointType) => ExtPointType;\n  };\n}\n\n// Legacy params. TODO: remove\nexport type CurveFn = {\n  CURVE: CurveType;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  sign: (message: Hex, privateKey: Hex, options?: { context?: Hex }) => Uint8Array;\n  verify: (\n    sig: Hex,\n    message: Hex,\n    publicKey: Hex,\n    options?: { context?: Hex; zip215: boolean }\n  ) => boolean;\n  Point: ExtPointConstructor;\n  /** @deprecated use `Point` */\n  ExtendedPoint: ExtPointConstructor;\n  utils: {\n    randomPrivateKey: () => Uint8Array;\n    getExtendedPublicKey: (key: Hex) => {\n      head: Uint8Array;\n      prefix: Uint8Array;\n      scalar: bigint;\n      point: ExtPointType;\n      pointBytes: Uint8Array;\n    };\n    precompute: (windowSize?: number, point?: ExtPointType) => ExtPointType;\n  };\n};\n\nfunction isEdValidXY(Fp: IField<bigint>, CURVE: EdwardsOpts, x: bigint, y: bigint): boolean {\n  const x2 = Fp.sqr(x);\n  const y2 = Fp.sqr(y);\n  const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n  const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n  return Fp.eql(left, right);\n}\n\nexport function edwards(CURVE: EdwardsOpts, curveOpts: EdwardsExtraOpts = {}): ExtPointConstructor {\n  const { Fp, Fn } = _createCurveFields('edwards', CURVE, curveOpts);\n  const { h: cofactor, n: CURVE_ORDER } = CURVE;\n  _validateObject(curveOpts, {}, { uvRatio: 'function' });\n\n  // Important:\n  // There are some places where Fp.BYTES is used instead of nByteLength.\n  // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n  // TODO: test and find curves which behave otherwise.\n  const MASK = _2n << (BigInt(Fn.BYTES * 8) - _1n);\n  const modP = (n: bigint) => Fp.create(n); // Function overrides\n\n  // sqrt(u/v)\n  const uvRatio =\n    curveOpts.uvRatio ||\n    ((u: bigint, v: bigint) => {\n      try {\n        return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };\n      } catch (e) {\n        return { isValid: false, value: _0n };\n      }\n    });\n\n  // Validate whether the passed curve params are valid.\n  // equation ax² + y² = 1 + dx²y² should work for generator point.\n  if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))\n    throw new Error('bad curve params: generator point');\n\n  /**\n   * Asserts coordinate is valid: 0 <= n < MASK.\n   * Coordinates >= Fp.ORDER are allowed for zip215.\n   */\n  function acoord(title: string, n: bigint, banZero = false) {\n    const min = banZero ? _1n : _0n;\n    aInRange('coordinate ' + title, n, min, MASK);\n    return n;\n  }\n\n  function aextpoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');\n  }\n  // Converts Extended point to default (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  const toAffineMemo = memoized((p: Point, iz?: bigint): AffinePoint<bigint> => {\n    const { ex: x, ey: y, ez: z } = p;\n    const is0 = p.is0();\n    if (iz == null) iz = is0 ? _8n : (Fp.inv(z) as bigint); // 8 was chosen arbitrarily\n    const ax = modP(x * iz);\n    const ay = modP(y * iz);\n    const zz = modP(z * iz);\n    if (is0) return { x: _0n, y: _1n };\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return { x: ax, y: ay };\n  });\n  const assertValidMemo = memoized((p: Point) => {\n    const { a, d } = CURVE;\n    if (p.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n    // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n    // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n    const { ex: X, ey: Y, ez: Z, et: T } = p;\n    const X2 = modP(X * X); // X²\n    const Y2 = modP(Y * Y); // Y²\n    const Z2 = modP(Z * Z); // Z²\n    const Z4 = modP(Z2 * Z2); // Z⁴\n    const aX2 = modP(X2 * a); // aX²\n    const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n    const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n    if (left !== right) throw new Error('bad point: equation left != right (1)');\n    // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n    const XY = modP(X * Y);\n    const ZT = modP(Z * T);\n    if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    return true;\n  });\n\n  // Extended Point works in extended coordinates: (X, Y, Z, T) ∋ (x=X/Z, y=Y/Z, T=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point implements ExtPointType {\n    // base / generator point\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    // zero / infinity / identity point\n    static readonly ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    // fields\n    static readonly Fp = Fp;\n    static readonly Fn = Fn;\n\n    readonly ex: bigint;\n    readonly ey: bigint;\n    readonly ez: bigint;\n    readonly et: bigint;\n\n    constructor(ex: bigint, ey: bigint, ez: bigint, et: bigint) {\n      this.ex = acoord('x', ex);\n      this.ey = acoord('y', ey);\n      this.ez = acoord('z', ez, true);\n      this.et = acoord('t', et);\n      Object.freeze(this);\n    }\n\n    get x(): bigint {\n      return this.toAffine().x;\n    }\n    get y(): bigint {\n      return this.toAffine().y;\n    }\n\n    static fromAffine(p: AffinePoint<bigint>): Point {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const { x, y } = p || {};\n      acoord('x', x);\n      acoord('y', y);\n      return new Point(x, y, _1n, modP(x * y));\n    }\n    static normalizeZ(points: Point[]): Point[] {\n      return normalizeZ(Point, 'ez', points);\n    }\n    // Multiscalar Multiplication\n    static msm(points: Point[], scalars: bigint[]): Point {\n      return pippenger(Point, Fn, points, scalars);\n    }\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      this.precompute(windowSize);\n    }\n    precompute(windowSize: number = 8, isLazy = true) {\n      wnaf.setWindowSize(this, windowSize);\n      if (!isLazy) this.multiply(_2n); // random number\n      return this;\n    }\n    // Not required for fromHex(), which always creates valid points.\n    // Could be useful for fromAffine().\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    // Compare one point to another.\n    equals(other: Point): boolean {\n      aextpoint(other);\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2 } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n\n    is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    negate(): Point {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n    }\n\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double(): Point {\n      const { a } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other: Point) {\n      aextpoint(other);\n      const { a, d } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    subtract(other: Point): Point {\n      return this.add(other.negate());\n    }\n\n    // Constant-time multiplication.\n    multiply(scalar: bigint): Point {\n      const n = scalar;\n      aInRange('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L\n      const { p, f } = wnaf.wNAFCached(this, n, Point.normalizeZ);\n      return Point.normalizeZ([p, f])[0];\n    }\n\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n    multiplyUnsafe(scalar: bigint, acc = Point.ZERO): Point {\n      const n = scalar;\n      aInRange('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L\n      if (n === _0n) return Point.ZERO;\n      if (this.is0() || n === _1n) return this;\n      return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);\n    }\n\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder(): boolean {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree(): boolean {\n      return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();\n    }\n\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(invertedZ?: bigint): AffinePoint<bigint> {\n      return toAffineMemo(this, invertedZ);\n    }\n\n    clearCofactor(): Point {\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    static fromBytes(bytes: Uint8Array, zip215 = false): Point {\n      abytes(bytes);\n      return this.fromHex(bytes, zip215);\n    }\n\n    // Converts hash string or Uint8Array to Point.\n    // Uses algo from RFC8032 5.1.3.\n    static fromHex(hex: Hex, zip215 = false): Point {\n      const { d, a } = CURVE;\n      const len = Fp.BYTES;\n      hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n      abool('zip215', zip215);\n      const normed = hex.slice(); // copy again, we'll manipulate it\n      const lastByte = hex[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = bytesToNumberLE(normed);\n\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // RFC8032 prohibits >= p, but ZIP215 doesn't\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      const max = zip215 ? MASK : Fp.ORDER;\n      aInRange('pointHex.y', y, _0n, max);\n\n      // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n      // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y² - 1\n      const v = modP(d * y2 - a); // v = d y² + 1.\n      let { isValid, value: x } = uvRatio(u, v); // √(u/v)\n      if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('Point.fromHex: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({ x, y });\n    }\n    static fromPrivateScalar(scalar: bigint): Point {\n      return Point.BASE.multiply(scalar);\n    }\n    toBytes(): Uint8Array {\n      const { x, y } = this.toAffine();\n      const bytes = numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n      return bytes; // and use the last byte to encode sign of x\n    }\n    /** @deprecated use `toBytes` */\n    toRawBytes(): Uint8Array {\n      return this.toBytes();\n    }\n    toHex(): string {\n      return bytesToHex(this.toBytes());\n    }\n\n    toString() {\n      return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n    }\n  }\n  const wnaf = wNAF(Point, Fn.BYTES * 8); // Fn.BITS?\n  return Point;\n}\n\n/**\n * Initializes EdDSA signatures over given Edwards curve.\n */\nexport function eddsa(Point: ExtPointConstructor, eddsaOpts: EdDSAOpts): EdDSA {\n  _validateObject(\n    eddsaOpts,\n    {\n      hash: 'function',\n    },\n    {\n      adjustScalarBytes: 'function',\n      randomBytes: 'function',\n      domain: 'function',\n      prehash: 'function',\n      mapToCurve: 'function',\n    }\n  );\n\n  const { prehash, hash: cHash } = eddsaOpts;\n  const { BASE: G, Fp, Fn } = Point;\n  const CURVE_ORDER = Fn.ORDER;\n\n  const randomBytes_ = eddsaOpts.randomBytes || randomBytes;\n  const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes: Uint8Array) => bytes); // NOOP\n  const domain =\n    eddsaOpts.domain ||\n    ((data: Uint8Array, ctx: Uint8Array, phflag: boolean) => {\n      abool('phflag', phflag);\n      if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n      return data;\n    }); // NOOP\n\n  function modN(a: bigint) {\n    return Fn.create(a);\n  }\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash: Uint8Array): bigint {\n    // Not using Fn.fromBytes: hash can be 2*Fn.BYTES\n    return modN(bytesToNumberLE(hash));\n  }\n\n  // Get the hashed private scalar per RFC8032 5.1.5\n  function getPrivateScalar(key: Hex) {\n    const len = Fp.BYTES;\n    key = ensureBytes('private key', key, len);\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    return { head, prefix, scalar };\n  }\n\n  // Convenience method that creates public key from scalar. RFC8032 5.1.5\n  function getExtendedPublicKey(key: Hex) {\n    const { head, prefix, scalar } = getPrivateScalar(key);\n    const point = G.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toBytes();\n    return { head, prefix, scalar, point, pointBytes };\n  }\n\n  // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n  function getPublicKey(privKey: Hex): Uint8Array {\n    return getExtendedPublicKey(privKey).pointBytes;\n  }\n\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar(context: Hex = Uint8Array.of(), ...msgs: Uint8Array[]) {\n    const msg = concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n  }\n\n  /** Signs message with privateKey. RFC8032 5.1.6 */\n  function sign(msg: Hex, privKey: Hex, options: { context?: Hex } = {}): Uint8Array {\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = G.multiply(r).toBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = modN(r + k * scalar); // S = (r + k * s) mod L\n    aInRange('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l\n    const L = Fp.BYTES;\n    const res = concatBytes(R, numberToBytesLE(s, L));\n    return ensureBytes('result', res, L * 2); // 64-byte signature\n  }\n\n  const verifyOpts: { context?: Hex; zip215?: boolean } = VERIFY_DEFAULT;\n\n  /**\n   * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n   * An extended group equation is checked.\n   */\n  function verify(sig: Hex, msg: Hex, publicKey: Hex, options = verifyOpts): boolean {\n    const { context, zip215 } = options;\n    const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n    sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n    msg = ensureBytes('message', msg);\n    publicKey = ensureBytes('publicKey', publicKey, len);\n    if (zip215 !== undefined) abool('zip215', zip215);\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n\n    const s = bytesToNumberLE(sig.slice(len, 2 * len));\n    let A, R, SB;\n    try {\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      A = Point.fromHex(publicKey, zip215);\n      R = Point.fromHex(sig.slice(0, len), zip215);\n      SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false;\n\n    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // Extended group equation\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().is0();\n  }\n\n  G.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n\n  const utils = {\n    getExtendedPublicKey,\n    /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */\n    randomPrivateKey: (): Uint8Array => randomBytes_!(Fp.BYTES),\n\n    /**\n     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n     * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n     * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n     * @param windowSize 2, 4, 8, 16\n     */\n    precompute(windowSize = 8, point: ExtPointType = Point.BASE): ExtPointType {\n      return point.precompute(windowSize, false);\n    },\n  };\n\n  return { getPublicKey, sign, verify, utils, Point };\n}\n\nexport type EdComposed = {\n  CURVE: EdwardsOpts;\n  curveOpts: EdwardsExtraOpts;\n  eddsaOpts: EdDSAOpts;\n};\nfunction _eddsa_legacy_opts_to_new(c: CurveTypeWithLength): EdComposed {\n  const CURVE: EdwardsOpts = {\n    a: c.a,\n    d: c.d,\n    p: c.Fp.ORDER,\n    n: c.n,\n    h: c.h,\n    Gx: c.Gx,\n    Gy: c.Gy,\n  };\n  const Fp = c.Fp;\n  const Fn = Field(CURVE.n, c.nBitLength, true);\n  const curveOpts: EdwardsExtraOpts = { Fp, Fn, uvRatio: c.uvRatio };\n  const eddsaOpts: EdDSAOpts = {\n    hash: c.hash,\n    randomBytes: c.randomBytes,\n    adjustScalarBytes: c.adjustScalarBytes,\n    domain: c.domain,\n    prehash: c.prehash,\n    mapToCurve: c.mapToCurve,\n  };\n  return { CURVE, curveOpts, eddsaOpts };\n}\nfunction _eddsa_new_output_to_legacy(c: CurveTypeWithLength, eddsa: EdDSA): CurveFn {\n  const legacy = Object.assign({}, eddsa, { ExtendedPoint: eddsa.Point, CURVE: c });\n  return legacy;\n}\n// TODO: remove. Use eddsa\nexport function twistedEdwards(c: CurveTypeWithLength): CurveFn {\n  const { CURVE, curveOpts, eddsaOpts } = _eddsa_legacy_opts_to_new(c);\n  const Point = edwards(CURVE, curveOpts);\n  const EDDSA = eddsa(Point, eddsaOpts);\n  return _eddsa_new_output_to_legacy(c, EDDSA);\n}\n", "/**\n * hash-to-curve from RFC 9380.\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * https://www.rfc-editor.org/rfc/rfc9380\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport type { CHash } from '../utils.ts';\nimport {\n  _validateObject,\n  abytes,\n  bytesToNumberBE,\n  concatBytes,\n  isBytes,\n  isHash,\n  utf8ToBytes,\n} from '../utils.ts';\nimport type { AffinePoint, Group, GroupConstructor } from './curve.ts';\nimport { FpInvertBatch, type IField, mod } from './modular.ts';\n\nexport type UnicodeOrBytes = string | Uint8Array;\n\n/**\n * * `DST` is a domain separation tag, defined in section 2.2.5\n * * `p` characteristic of F, where F is a finite field of characteristic p and order q = p^m\n * * `m` is extension degree (1 for prime fields)\n * * `k` is the target security target in bits (e.g. 128), from section 5.1\n * * `expand` is `xmd` (SHA2, SHA3, BLAKE) or `xof` (SHAKE, BLAKE-XOF)\n * * `hash` conforming to `utils.CHash` interface, with `outputLen` / `blockLen` props\n */\nexport type H2COpts = {\n  DST: UnicodeOrBytes;\n  expand: 'xmd' | 'xof';\n  hash: CHash;\n  p: bigint;\n  m: number;\n  k: number;\n};\nexport type H2CHashOpts = {\n  expand: 'xmd' | 'xof';\n  hash: CHash;\n};\n// todo: remove\nexport type Opts = H2COpts;\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = bytesToNumberBE;\n\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value: number, length: number): Uint8Array {\n  anum(value);\n  anum(length);\n  if (value < 0 || value >= 1 << (8 * length)) throw new Error('invalid I2OSP input: ' + value);\n  const res = Array.from({ length }).fill(0) as number[];\n  for (let i = length - 1; i >= 0; i--) {\n    res[i] = value & 0xff;\n    value >>>= 8;\n  }\n  return new Uint8Array(res);\n}\n\nfunction strxor(a: Uint8Array, b: Uint8Array): Uint8Array {\n  const arr = new Uint8Array(a.length);\n  for (let i = 0; i < a.length; i++) {\n    arr[i] = a[i] ^ b[i];\n  }\n  return arr;\n}\n\nfunction anum(item: unknown): void {\n  if (!Number.isSafeInteger(item)) throw new Error('number expected');\n}\n\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */\nexport function expand_message_xmd(\n  msg: Uint8Array,\n  DST: Uint8Array,\n  lenInBytes: number,\n  H: CHash\n): Uint8Array {\n  abytes(msg);\n  abytes(DST);\n  anum(lenInBytes);\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n  if (DST.length > 255) DST = H(concatBytes(utf8ToBytes('H2C-OVERSIZE-DST-'), DST));\n  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n  const ell = Math.ceil(lenInBytes / b_in_bytes);\n  if (lenInBytes > 65535 || ell > 255) throw new Error('expand_message_xmd: invalid lenInBytes');\n  const DST_prime = concatBytes(DST, i2osp(DST.length, 1));\n  const Z_pad = i2osp(0, r_in_bytes);\n  const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n  const b = new Array<Uint8Array>(ell);\n  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n  b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));\n  for (let i = 1; i <= ell; i++) {\n    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n    b[i] = H(concatBytes(...args));\n  }\n  const pseudo_random_bytes = concatBytes(...b);\n  return pseudo_random_bytes.slice(0, lenInBytes);\n}\n\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */\nexport function expand_message_xof(\n  msg: Uint8Array,\n  DST: Uint8Array,\n  lenInBytes: number,\n  k: number,\n  H: CHash\n): Uint8Array {\n  abytes(msg);\n  abytes(DST);\n  anum(lenInBytes);\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n  // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n  if (DST.length > 255) {\n    const dkLen = Math.ceil((2 * k) / 8);\n    DST = H.create({ dkLen }).update(utf8ToBytes('H2C-OVERSIZE-DST-')).update(DST).digest();\n  }\n  if (lenInBytes > 65535 || DST.length > 255)\n    throw new Error('expand_message_xof: invalid lenInBytes');\n  return (\n    H.create({ dkLen: lenInBytes })\n      .update(msg)\n      .update(i2osp(lenInBytes, 2))\n      // 2. DST_prime = DST || I2OSP(len(DST), 1)\n      .update(DST)\n      .update(i2osp(DST.length, 1))\n      .digest()\n  );\n}\n\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nexport function hash_to_field(msg: Uint8Array, count: number, options: H2COpts): bigint[][] {\n  _validateObject(options, {\n    p: 'bigint',\n    m: 'number',\n    k: 'number',\n    hash: 'function',\n  });\n  const { p, k, m, hash, expand, DST: _DST } = options;\n  if (!isBytes(_DST) && typeof _DST !== 'string')\n    throw new Error('DST must be string or uint8array');\n  if (!isHash(options.hash)) throw new Error('expected valid hash');\n  abytes(msg);\n  anum(count);\n  const DST = typeof _DST === 'string' ? utf8ToBytes(_DST) : _DST;\n  const log2p = p.toString(2).length;\n  const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n  const len_in_bytes = count * m * L;\n  let prb; // pseudo_random_bytes\n  if (expand === 'xmd') {\n    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n  } else if (expand === 'xof') {\n    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n  } else if (expand === '_internal_pass') {\n    // for internal tests only\n    prb = msg;\n  } else {\n    throw new Error('expand must be \"xmd\" or \"xof\"');\n  }\n  const u = new Array(count);\n  for (let i = 0; i < count; i++) {\n    const e = new Array(m);\n    for (let j = 0; j < m; j++) {\n      const elm_offset = L * (j + i * m);\n      const tv = prb.subarray(elm_offset, elm_offset + L);\n      e[j] = mod(os2ip(tv), p);\n    }\n    u[i] = e;\n  }\n  return u;\n}\n\nexport type XY<T> = (x: T, y: T) => { x: T; y: T };\nexport type XYRatio<T> = [T[], T[], T[], T[]]; // xn/xd, yn/yd\nexport function isogenyMap<T, F extends IField<T>>(field: F, map: XYRatio<T>): XY<T> {\n  // Make same order as in spec\n  const coeff = map.map((i) => Array.from(i).reverse());\n  return (x: T, y: T) => {\n    const [xn, xd, yn, yd] = coeff.map((val) =>\n      val.reduce((acc, i) => field.add(field.mul(acc, x), i))\n    );\n    // 6.6.3\n    // Exceptional cases of iso_map are inputs that cause the denominator of\n    // either rational function to evaluate to zero; such cases MUST return\n    // the identity point on E.\n    const [xd_inv, yd_inv] = FpInvertBatch(field, [xd, yd], true);\n    x = field.mul(xn, xd_inv); // xNum / xDen\n    y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)\n    return { x, y };\n  };\n}\n\n/** Point interface, which curves must implement to work correctly with the module. */\nexport interface H2CPoint<T> extends Group<H2CPoint<T>> {\n  add(rhs: H2CPoint<T>): H2CPoint<T>;\n  toAffine(iz?: bigint): AffinePoint<T>;\n  clearCofactor(): H2CPoint<T>;\n  assertValidity(): void;\n}\n\nexport interface H2CPointConstructor<T> extends GroupConstructor<H2CPoint<T>> {\n  fromAffine(ap: AffinePoint<T>): H2CPoint<T>;\n}\n\nexport type MapToCurve<T> = (scalar: bigint[]) => AffinePoint<T>;\n\n// Separated from initialization opts, so users won't accidentally change per-curve parameters\n// (changing DST is ok!)\nexport type htfBasicOpts = { DST: UnicodeOrBytes };\nexport type H2CMethod<T> = (msg: Uint8Array, options?: htfBasicOpts) => H2CPoint<T>;\n// TODO: remove\nexport type HTFMethod<T> = H2CMethod<T>;\nexport type MapMethod<T> = (scalars: bigint[]) => H2CPoint<T>;\n/**\n * RFC 9380 methods, with cofactor clearing. See https://www.rfc-editor.org/rfc/rfc9380#section-3.\n *\n * * hashToCurve: `map(hash(input))`, encodes RANDOM bytes to curve (WITH hashing)\n * * encodeToCurve: `map(hash(input))`, encodes NON-UNIFORM bytes to curve (WITH hashing)\n * * mapToCurve: `map(scalars)`, encodes NON-UNIFORM scalars to curve (NO hashing)\n */\nexport type H2CHasher<T> = {\n  hashToCurve: H2CMethod<T>;\n  encodeToCurve: H2CMethod<T>;\n  mapToCurve: MapMethod<T>;\n  defaults: H2COpts & { encodeDST?: UnicodeOrBytes };\n};\n// TODO: remove\nexport type Hasher<T> = H2CHasher<T>;\n\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. See {@link H2CHasher}. */\nexport function createHasher<T>(\n  Point: H2CPointConstructor<T>,\n  mapToCurve: MapToCurve<T>,\n  defaults: H2COpts & { encodeDST?: UnicodeOrBytes }\n): H2CHasher<T> {\n  if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');\n  function map(num: bigint[]) {\n    return Point.fromAffine(mapToCurve(num));\n  }\n  function clear(initial: H2CPoint<T>) {\n    const P = initial.clearCofactor();\n    if (P.equals(Point.ZERO)) return Point.ZERO; // zero will throw in assert\n    P.assertValidity();\n    return P;\n  }\n\n  return {\n    defaults,\n    hashToCurve(msg: Uint8Array, options?: htfBasicOpts): H2CPoint<T> {\n      const dst = defaults.DST ? defaults.DST : {};\n      const opts = Object.assign({}, defaults, dst, options);\n      const u = hash_to_field(msg, 2, opts);\n      const u0 = map(u[0]);\n      const u1 = map(u[1]);\n      return clear(u0.add(u1));\n    },\n    encodeToCurve(msg: Uint8Array, options?: htfBasicOpts): H2CPoint<T> {\n      const dst = defaults.encodeDST ? defaults.encodeDST : {};\n      const opts = Object.assign({}, defaults, dst, options);\n      const u = hash_to_field(msg, 1, opts);\n      return clear(map(u[0]));\n    },\n    /** See {@link H2CHasher} */\n    mapToCurve(scalars: bigint[]): H2CPoint<T> {\n      if (!Array.isArray(scalars)) throw new Error('expected array of bigints');\n      for (const i of scalars)\n        if (typeof i !== 'bigint') throw new Error('expected array of bigints');\n      return clear(map(scalars));\n    },\n  };\n}\n", "/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  _validateObject,\n  aInRange,\n  bytesToNumberLE,\n  ensureBytes,\n  numberToBytesLE,\n  randomBytes,\n} from '../utils.ts';\nimport { mod } from './modular.ts';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\ntype Hex = string | Uint8Array;\n\nexport type CurveType = {\n  P: bigint; // finite field prime\n  type: 'x25519' | 'x448';\n  adjustScalarBytes: (bytes: Uint8Array) => Uint8Array;\n  powPminus2: (x: bigint) => bigint;\n  randomBytes?: (bytesLength?: number) => Uint8Array;\n};\n\nexport type CurveFn = {\n  scalarMult: (scalar: Hex, u: Hex) => Uint8Array;\n  scalarMultBase: (scalar: Hex) => Uint8Array;\n  getSharedSecret: (privateKeyA: Hex, publicKeyB: Hex) => Uint8Array;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  utils: { randomPrivateKey: () => Uint8Array };\n  GuBytes: Uint8Array;\n};\n\nfunction validateOpts(curve: CurveType) {\n  _validateObject(curve, {\n    adjustScalarBytes: 'function',\n    powPminus2: 'function',\n  });\n  return Object.freeze({ ...curve } as const);\n}\n\nexport function montgomery(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef);\n  const { P, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;\n  const is25519 = type === 'x25519';\n  if (!is25519 && type !== 'x448') throw new Error('invalid type');\n  const randomBytes_ = rand || randomBytes;\n\n  const montgomeryBits = is25519 ? 255 : 448;\n  const fieldLen = is25519 ? 32 : 56;\n  const Gu = is25519 ? BigInt(9) : BigInt(5);\n  // RFC 7748 #5:\n  // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and\n  // (156326 - 2) / 4 = 39081 for curve448/X448\n  // const a = is25519 ? 156326n : 486662n;\n  const a24 = is25519 ? BigInt(121665) : BigInt(39081);\n  // RFC: x25519 \"the resulting integer is of the form 2^254 plus\n  // eight times a value between 0 and 2^251 - 1 (inclusive)\"\n  // x448: \"2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)\"\n  const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);\n  const maxAdded = is25519\n    ? BigInt(8) * _2n ** BigInt(251) - _1n\n    : BigInt(4) * _2n ** BigInt(445) - _1n;\n  const maxScalar = minScalar + maxAdded + _1n; // (inclusive)\n  const modP = (n: bigint) => mod(n, P);\n  const GuBytes = encodeU(Gu);\n  function encodeU(u: bigint): Uint8Array {\n    return numberToBytesLE(modP(u), fieldLen);\n  }\n  function decodeU(u: Hex): bigint {\n    const _u = ensureBytes('u coordinate', u, fieldLen);\n    // RFC: When receiving such an array, implementations of X25519\n    // (but not X448) MUST mask the most significant bit in the final byte.\n    if (is25519) _u[31] &= 127; // 0b0111_1111\n    // RFC: Implementations MUST accept non-canonical values and process them as\n    // if they had been reduced modulo the field prime.  The non-canonical\n    // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224\n    // - 1 through 2^448 - 1 for X448.\n    return modP(bytesToNumberLE(_u));\n  }\n  function decodeScalar(scalar: Hex): bigint {\n    return bytesToNumberLE(adjustScalarBytes(ensureBytes('scalar', scalar, fieldLen)));\n  }\n  function scalarMult(scalar: Hex, u: Hex): Uint8Array {\n    const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));\n    // Some public keys are useless, of low-order. Curve author doesn't think\n    // it needs to be validated, but we do it nonetheless.\n    // https://cr.yp.to/ecdh.html#validate\n    if (pu === _0n) throw new Error('invalid private or public key received');\n    return encodeU(pu);\n  }\n  // Computes public key from private. By doing scalar multiplication of base point.\n  function scalarMultBase(scalar: Hex): Uint8Array {\n    return scalarMult(scalar, GuBytes);\n  }\n\n  // cswap from RFC7748 \"example code\"\n  function cswap(swap: bigint, x_2: bigint, x_3: bigint): { x_2: bigint; x_3: bigint } {\n    // dummy = mask(swap) AND (x_2 XOR x_3)\n    // Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n    // and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    const dummy = modP(swap * (x_2 - x_3));\n    x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy\n    x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy\n    return { x_2, x_3 };\n  }\n\n  /**\n   * Montgomery x-only multiplication ladder.\n   * @param pointU u coordinate (x) on Montgomery Curve 25519\n   * @param scalar by which the point would be multiplied\n   * @returns new Point on Montgomery curve\n   */\n  function montgomeryLadder(u: bigint, scalar: bigint): bigint {\n    aInRange('u', u, _0n, P);\n    aInRange('scalar', scalar, minScalar, maxScalar);\n    const k = scalar;\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n      const k_t = (k >> t) & _1n;\n      swap ^= k_t;\n      ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n      swap = k_t;\n\n      const A = x_2 + z_2;\n      const AA = modP(A * A);\n      const B = x_2 - z_2;\n      const BB = modP(B * B);\n      const E = AA - BB;\n      const C = x_3 + z_3;\n      const D = x_3 - z_3;\n      const DA = modP(D * A);\n      const CB = modP(C * B);\n      const dacb = DA + CB;\n      const da_cb = DA - CB;\n      x_3 = modP(dacb * dacb);\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\n      x_2 = modP(AA * BB);\n      z_2 = modP(E * (AA + modP(a24 * E)));\n    }\n    ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n    ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n    const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent\n    return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))\n  }\n\n  return {\n    scalarMult,\n    scalarMultBase,\n    getSharedSecret: (privateKey: Hex, publicKey: Hex) => scalarMult(privateKey, publicKey),\n    getPublicKey: (privateKey: Hex): Uint8Array => scalarMultBase(privateKey),\n    utils: { randomPrivateKey: () => randomBytes_(fieldLen) },\n    GuBytes: GuBytes.slice(),\n  };\n}\n", "/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha512 } from '@noble/hashes/sha2.js';\nimport { abytes, concatBytes, utf8ToBytes } from '@noble/hashes/utils.js';\nimport { type AffinePoint, type Group, pippenger } from './abstract/curve.ts';\nimport {\n  type CurveFn,\n  type EdwardsOpts,\n  type ExtPointType,\n  twistedEdwards,\n} from './abstract/edwards.ts';\nimport {\n  createHasher,\n  expand_message_xmd,\n  type H2CHasher,\n  type H2CMethod,\n  type htfBasicOpts,\n} from './abstract/hash-to-curve.ts';\nimport { Field, FpInvertBatch, FpSqrtEven, isNegativeLE, mod, pow2 } from './abstract/modular.ts';\nimport { montgomery, type CurveFn as XCurveFn } from './abstract/montgomery.ts';\nimport {\n  bytesToHex,\n  bytesToNumberLE,\n  ensureBytes,\n  equalBytes,\n  type Hex,\n  numberToBytesLE,\n} from './utils.ts';\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\n\n// 2n**255n - 19n\n// Removing Fp.create() will still work, and is 10% faster on sign\n//     a: Fp.create(BigInt(-1)),\n// d is -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))\n// Finite field 2n**255n - 19n\n// Subgroup order 2n**252n + 27742317777372353535851937790883648493n;\nconst ed25519_CURVE: EdwardsOpts = {\n  p: BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed'),\n  n: BigInt('0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed'),\n  h: _8n,\n  a: BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec'),\n  d: BigInt('0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3'),\n  Gx: BigInt('0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a'),\n  Gy: BigInt('0x6666666666666666666666666666666666666666666666666666666666666658'),\n};\n\nfunction ed25519_pow_2_252_3(x: bigint) {\n  // prettier-ignore\n  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n  const P = ed25519_CURVE.p;\n  const x2 = (x * x) % P;\n  const b2 = (x2 * x) % P; // x^3, 11\n  const b4 = (pow2(b2, _2n, P) * b2) % P; // x^15, 1111\n  const b5 = (pow2(b4, _1n, P) * x) % P; // x^31\n  const b10 = (pow2(b5, _5n, P) * b5) % P;\n  const b20 = (pow2(b10, _10n, P) * b10) % P;\n  const b40 = (pow2(b20, _20n, P) * b20) % P;\n  const b80 = (pow2(b40, _40n, P) * b40) % P;\n  const b160 = (pow2(b80, _80n, P) * b80) % P;\n  const b240 = (pow2(b160, _80n, P) * b80) % P;\n  const b250 = (pow2(b240, _10n, P) * b10) % P;\n  const pow_p_5_8 = (pow2(b250, _2n, P) * x) % P;\n  // ^ To pow to (p+3)/8, multiply it by x.\n  return { pow_p_5_8, b2 };\n}\n\nfunction adjustScalarBytes(bytes: Uint8Array): Uint8Array {\n  // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n  // set the three least significant bits of the first byte\n  bytes[0] &= 248; // 0b1111_1000\n  // and the most significant bit of the last to zero,\n  bytes[31] &= 127; // 0b0111_1111\n  // set the second most significant bit of the last byte to 1\n  bytes[31] |= 64; // 0b0100_0000\n  return bytes;\n}\n\n// √(-1) aka √(a) aka 2^((p-1)/4)\n// Fp.sqrt(Fp.neg(1))\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt(\n  '19681161376707505956807079304988542015446066515923890162744021073123829784752'\n);\n// sqrt(u/v)\nfunction uvRatio(u: bigint, v: bigint): { isValid: boolean; value: bigint } {\n  const P = ed25519_CURVE.p;\n  const v3 = mod(v * v * v, P); // v³\n  const v7 = mod(v3 * v3 * v, P); // v⁷\n  // (p+3)/8 and (p-5)/8\n  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n  let x = mod(u * v3 * pow, P); // (uv³)(uv⁷)^(p-5)/8\n  const vx2 = mod(v * x * x, P); // vx²\n  const root1 = x; // First root candidate\n  const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate\n  const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n  const useRoot2 = vx2 === mod(-u, P); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx² = -u√(-1)\n  if (useRoot1) x = root1;\n  if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n  if (isNegativeLE(x, P)) x = mod(-x, P);\n  return { isValid: useRoot1 || useRoot2, value: x };\n}\n\n/** Weird / bogus points, useful for debugging. */\nexport const ED25519_TORSION_SUBGROUP: string[] = [\n  '0100000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n  '0000000000000000000000000000000000000000000000000000000000000080',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n  'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\n\nconst Fp = /* @__PURE__ */ (() => Field(ed25519_CURVE.p, undefined, true))();\n\nconst ed25519Defaults = /* @__PURE__ */ (() => ({\n  ...ed25519_CURVE,\n  Fp,\n  hash: sha512,\n  adjustScalarBytes,\n  // dom2\n  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n  // Constant-time, u/√v\n  uvRatio,\n}))();\n\n/**\n * ed25519 curve with EdDSA signatures.\n * @example\n * import { ed25519 } from '@noble/curves/ed25519';\n * const priv = ed25519.utils.randomPrivateKey();\n * const pub = ed25519.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = ed25519.sign(msg, priv);\n * ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215\n * ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5\n */\nexport const ed25519: CurveFn = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();\n\nfunction ed25519_domain(data: Uint8Array, ctx: Uint8Array, phflag: boolean) {\n  if (ctx.length > 255) throw new Error('Context is too big');\n  return concatBytes(\n    utf8ToBytes('SigEd25519 no Ed25519 collisions'),\n    new Uint8Array([phflag ? 1 : 0, ctx.length]),\n    ctx,\n    data\n  );\n}\n\nexport const ed25519ctx: CurveFn = /* @__PURE__ */ (() =>\n  twistedEdwards({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n  }))();\nexport const ed25519ph: CurveFn = /* @__PURE__ */ (() =>\n  twistedEdwards(\n    Object.assign({}, ed25519Defaults, {\n      domain: ed25519_domain,\n      prehash: sha512,\n    })\n  ))();\n\n/**\n * ECDH using curve25519 aka x25519.\n * @example\n * import { x25519 } from '@noble/curves/ed25519';\n * const priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';\n * const pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';\n * x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases\n * x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);\n * x25519.getPublicKey(x25519.utils.randomPrivateKey());\n */\nexport const x25519: XCurveFn = /* @__PURE__ */ (() => {\n  const P = ed25519_CURVE.p;\n  return montgomery({\n    P,\n    type: 'x25519',\n    powPminus2: (x: bigint): bigint => {\n      // x^(p-2) aka x^(2^255-21)\n      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n      return mod(pow2(pow_p_5_8, _3n, P) * b2, P);\n    },\n    adjustScalarBytes,\n  });\n})();\n\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */\nexport function edwardsToMontgomeryPub(edwardsPub: Hex): Uint8Array {\n  const bpub = ensureBytes('pub', edwardsPub);\n  const { y } = ed25519.Point.fromHex(bpub);\n  const _1n = BigInt(1);\n  return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nexport const edwardsToMontgomery: typeof edwardsToMontgomeryPub = edwardsToMontgomeryPub; // deprecated\n\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */\nexport function edwardsToMontgomeryPriv(edwardsPriv: Uint8Array): Uint8Array {\n  const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n  return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\n\nconst ELL2_C1 = /* @__PURE__ */ (() => (Fp.ORDER + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u: bigint) {\n  const ELL2_C4 = (Fp.ORDER - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n  const ELL2_J = BigInt(486662);\n\n  let tv1 = Fp.sqr(u);          //  1.  tv1 = u^2\n  tv1 = Fp.mul(tv1, _2n);       //  2.  tv1 = 2 * tv1\n  let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n  let x1n = Fp.neg(ELL2_J);     //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n  let tv2 = Fp.sqr(xd);         //  5.  tv2 = xd^2\n  let gxd = Fp.mul(tv2, xd);    //  6.  gxd = tv2 * xd        # gxd = xd^3\n  let gx1 = Fp.mul(tv1, ELL2_J);//  7.  gx1 = J * tv1         # x1n + J * xd\n  gx1 = Fp.mul(gx1, x1n);       //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n  gx1 = Fp.add(gx1, tv2);       //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n  gx1 = Fp.mul(gx1, x1n);       //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n  let tv3 = Fp.sqr(gxd);        //  11. tv3 = gxd^2\n  tv2 = Fp.sqr(tv3);            //  12. tv2 = tv3^2           # gxd^4\n  tv3 = Fp.mul(tv3, gxd);       //  13. tv3 = tv3 * gxd       # gxd^3\n  tv3 = Fp.mul(tv3, gx1);       //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n  tv2 = Fp.mul(tv2, tv3);       //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n  let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n  y11 = Fp.mul(y11, tv3);       //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n  let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n  tv2 = Fp.sqr(y11);            //  19. tv2 = y11^2\n  tv2 = Fp.mul(tv2, gxd);       //  20. tv2 = tv2 * gxd\n  let e1 = Fp.eql(tv2, gx1);    //  21.  e1 = tv2 == gx1\n  let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n  let x2n = Fp.mul(x1n, tv1);   //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n  let y21 = Fp.mul(y11, u);     //  24. y21 = y11 * u\n  y21 = Fp.mul(y21, ELL2_C2);   //  25. y21 = y21 * c2\n  let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n  let gx2 = Fp.mul(gx1, tv1);   //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n  tv2 = Fp.sqr(y21);            //  28. tv2 = y21^2\n  tv2 = Fp.mul(tv2, gxd);       //  29. tv2 = tv2 * gxd\n  let e2 = Fp.eql(tv2, gx2);    //  30.  e2 = tv2 == gx2\n  let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n  tv2 = Fp.sqr(y1);             //  32. tv2 = y1^2\n  tv2 = Fp.mul(tv2, gxd);       //  33. tv2 = tv2 * gxd\n  let e3 = Fp.eql(tv2, gx1);    //  34.  e3 = tv2 == gx1\n  let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n  let y = Fp.cmov(y2, y1, e3);  //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n  let e4 = Fp.isOdd(y);         //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n  y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\n\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u: bigint) {\n  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n  // map_to_curve_elligator2_curve25519(u)\n  let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n  xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n  let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n  let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n  let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n  let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n  let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n  xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n  xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n  yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n  yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n  const [xd_inv, yd_inv] = FpInvertBatch(Fp, [xd, yd], true); // batch division\n  return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) }; //  13. return (xn, xd, yn, yd)\n}\n\nexport const ed25519_hasher: H2CHasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(\n    ed25519.Point,\n    (scalars: bigint[]) => map_to_curve_elligator2_edwards25519(scalars[0]),\n    {\n      DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n      encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n      p: Fp.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha512,\n    }\n  ))();\nexport const hashToCurve: H2CMethod<bigint> = /* @__PURE__ */ (() => ed25519_hasher.hashToCurve)();\nexport const encodeToCurve: H2CMethod<bigint> = /* @__PURE__ */ (() =>\n  ed25519_hasher.encodeToCurve)();\n\nfunction aristp(other: unknown) {\n  if (!(other instanceof RistPoint)) throw new Error('RistrettoPoint expected');\n}\n\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// √(ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt(\n  '25063068953384623474111414158702152701244531502492656460079210482610430750235'\n);\n// 1 / √(a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt(\n  '54469307008909316920995813868745141605393597292927456921205312896311721017578'\n);\n// 1-d²\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt(\n  '1159843021668779879193775521855586647937357759715417654439879720876111806838'\n);\n// (d-1)²\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt(\n  '40440834346308536858101042469323190826248399146238708352240133220865137265952'\n);\n// Calculates 1/√(number)\nconst invertSqrt = (number: bigint) => uvRatio(_1n, number);\n\nconst MAX_255B = /* @__PURE__ */ BigInt(\n  '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n);\nconst bytes255ToNumberLE = (bytes: Uint8Array) =>\n  ed25519.CURVE.Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n\ntype ExtendedPoint = ExtPointType;\n\n/**\n * Computes Elligator map for Ristretto255.\n * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on\n * the [website](https://ristretto.group/formulas/elligator.html).\n */\nfunction calcElligatorRistrettoMap(r0: bigint): ExtendedPoint {\n  const { d } = ed25519.CURVE;\n  const P = ed25519.CURVE.Fp.ORDER;\n  const mod = ed25519.CURVE.Fp.create;\n  const r = mod(SQRT_M1 * r0 * r0); // 1\n  const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n  let c = BigInt(-1); // 3\n  const D = mod((c - d * r) * mod(r + d)); // 4\n  let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n  let s_ = mod(s * r0); // 6\n  if (!isNegativeLE(s_, P)) s_ = mod(-s_);\n  if (!Ns_D_is_sq) s = s_; // 7\n  if (!Ns_D_is_sq) c = r; // 8\n  const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n  const s2 = s * s;\n  const W0 = mod((s + s) * D); // 10\n  const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n  const W2 = mod(_1n - s2); // 12\n  const W3 = mod(_1n + s2); // 13\n  return new ed25519.Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).\n */\nclass RistPoint implements Group<RistPoint> {\n  static BASE: RistPoint;\n  static ZERO: RistPoint;\n  private readonly ep: ExtendedPoint;\n  // Private property to discourage combining ExtendedPoint + RistrettoPoint\n  // Always use Ristretto encoding/decoding instead.\n  constructor(ep: ExtendedPoint) {\n    this.ep = ep;\n  }\n\n  static fromAffine(ap: AffinePoint<bigint>): RistPoint {\n    return new RistPoint(ed25519.Point.fromAffine(ap));\n  }\n\n  /**\n   * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n   * The hash-to-group operation applies Elligator twice and adds the results.\n   * **Note:** this is one-way map, there is no conversion from point to hash.\n   * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on\n   * the [website](https://ristretto.group/formulas/elligator.html).\n   * @param hex 64-byte output of a hash function\n   */\n  static hashToCurve(hex: Hex): RistPoint {\n    hex = ensureBytes('ristrettoHash', hex, 64);\n    const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n    const R1 = calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n    const R2 = calcElligatorRistrettoMap(r2);\n    return new RistPoint(R1.add(R2));\n  }\n\n  static fromBytes(bytes: Uint8Array): RistPoint {\n    abytes(bytes);\n    return this.fromHex(bytes);\n  }\n\n  /**\n   * Converts ristretto-encoded string to ristretto point.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).\n   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n   */\n  static fromHex(hex: Hex): RistPoint {\n    hex = ensureBytes('ristrettoHex', hex, 32);\n    const { a, d } = ed25519.CURVE;\n    const P = Fp.ORDER;\n    const mod = Fp.create;\n    const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n    const s = bytes255ToNumberLE(hex);\n    // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n    // 3. Check that s is non-negative, or else abort\n    if (!equalBytes(numberToBytesLE(s, 32), hex) || isNegativeLE(s, P)) throw new Error(emsg);\n    const s2 = mod(s * s);\n    const u1 = mod(_1n + a * s2); // 4 (a is -1)\n    const u2 = mod(_1n - a * s2); // 5\n    const u1_2 = mod(u1 * u1);\n    const u2_2 = mod(u2 * u2);\n    const v = mod(a * d * u1_2 - u2_2); // 6\n    const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n    const Dx = mod(I * u2); // 8\n    const Dy = mod(I * Dx * v); // 9\n    let x = mod((s + s) * Dx); // 10\n    if (isNegativeLE(x, P)) x = mod(-x); // 10\n    const y = mod(u1 * Dy); // 11\n    const t = mod(x * y); // 12\n    if (!isValid || isNegativeLE(t, P) || y === _0n) throw new Error(emsg);\n    return new RistPoint(new ed25519.Point(x, y, _1n, t));\n  }\n\n  static msm(points: RistPoint[], scalars: bigint[]): RistPoint {\n    const Fn = Field(ed25519.CURVE.n, ed25519.CURVE.nBitLength);\n    return pippenger(RistPoint, Fn, points, scalars);\n  }\n\n  /**\n   * Encodes ristretto point to Uint8Array.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).\n   */\n  toBytes(): Uint8Array {\n    let { ex: x, ey: y, ez: z, et: t } = this.ep;\n    const P = Fp.ORDER;\n    const mod = Fp.create;\n    const u1 = mod(mod(z + y) * mod(z - y)); // 1\n    const u2 = mod(x * y); // 2\n    // Square root always exists\n    const u2sq = mod(u2 * u2);\n    const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n    const D1 = mod(invsqrt * u1); // 4\n    const D2 = mod(invsqrt * u2); // 5\n    const zInv = mod(D1 * D2 * t); // 6\n    let D: bigint; // 7\n    if (isNegativeLE(t * zInv, P)) {\n      let _x = mod(y * SQRT_M1);\n      let _y = mod(x * SQRT_M1);\n      x = _x;\n      y = _y;\n      D = mod(D1 * INVSQRT_A_MINUS_D);\n    } else {\n      D = D2; // 8\n    }\n    if (isNegativeLE(x * zInv, P)) y = mod(-y); // 9\n    let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n    if (isNegativeLE(s, P)) s = mod(-s);\n    return numberToBytesLE(s, 32); // 11\n  }\n\n  /** @deprecated use `toBytes` */\n  toRawBytes(): Uint8Array {\n    return this.toBytes();\n  }\n\n  toHex(): string {\n    return bytesToHex(this.toBytes());\n  }\n\n  toString(): string {\n    return this.toHex();\n  }\n\n  /**\n   * Compares two Ristretto points.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).\n   */\n  equals(other: RistPoint): boolean {\n    aristp(other);\n    const { ex: X1, ey: Y1 } = this.ep;\n    const { ex: X2, ey: Y2 } = other.ep;\n    const mod = Fp.create;\n    // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n    const one = mod(X1 * Y2) === mod(Y1 * X2);\n    const two = mod(Y1 * Y2) === mod(X1 * X2);\n    return one || two;\n  }\n\n  add(other: RistPoint): RistPoint {\n    aristp(other);\n    return new RistPoint(this.ep.add(other.ep));\n  }\n\n  subtract(other: RistPoint): RistPoint {\n    aristp(other);\n    return new RistPoint(this.ep.subtract(other.ep));\n  }\n\n  multiply(scalar: bigint): RistPoint {\n    return new RistPoint(this.ep.multiply(scalar));\n  }\n\n  multiplyUnsafe(scalar: bigint): RistPoint {\n    return new RistPoint(this.ep.multiplyUnsafe(scalar));\n  }\n\n  double(): RistPoint {\n    return new RistPoint(this.ep.double());\n  }\n\n  negate(): RistPoint {\n    return new RistPoint(this.ep.negate());\n  }\n}\n\n/**\n * Wrapper over Edwards Point for ristretto255 from\n * [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).\n */\nexport const RistrettoPoint: typeof RistPoint = /* @__PURE__ */ (() => {\n  if (!RistPoint.BASE) RistPoint.BASE = new RistPoint(ed25519.Point.BASE);\n  if (!RistPoint.ZERO) RistPoint.ZERO = new RistPoint(ed25519.Point.ZERO);\n  return RistPoint;\n})();\n\n/**\n * hash-to-curve for ristretto255.\n * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B).\n */\nexport const hashToRistretto255 = (msg: Uint8Array, options: htfBasicOpts): RistPoint => {\n  const d = options.DST;\n  const DST = typeof d === 'string' ? utf8ToBytes(d) : d;\n  const uniform_bytes = expand_message_xmd(msg, DST, 64, sha512);\n  const P = RistPoint.hashToCurve(uniform_bytes);\n  return P;\n};\n/** @deprecated */\nexport const hash_to_ristretto255: (msg: Uint8Array, options: htfBasicOpts) => RistPoint =\n  hashToRistretto255; // legacy\n", "'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n", "/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n", "/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\nconst { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new GlobalUint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, GlobalUint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new GlobalUint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (GlobalArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, GlobalArrayBuffer) ||\n      (value && isInstance(value.buffer, GlobalArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof GlobalSharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, GlobalSharedArrayBuffer) ||\n      (value && isInstance(value.buffer, GlobalSharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, GlobalUint8Array.prototype)\nObject.setPrototypeOf(Buffer, GlobalUint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, GlobalUint8Array)) {\n    const copy = new GlobalUint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new GlobalUint8Array(array)\n  } else if (length === undefined) {\n    buf = new GlobalUint8Array(array, byteOffset)\n  } else {\n    buf = new GlobalUint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, GlobalUint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, GlobalUint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, GlobalUint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        GlobalUint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, GlobalUint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof GlobalUint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof GlobalUint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    GlobalUint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n", "import {\n  Blob,\n  BlobOptions,\n  Buffer,\n  File,\n  FileOptions,\n  INSPECT_MAX_BYTES,\n  // eslint-disable-next-line n/no-deprecated-api\n  SlowBuffer,\n  TranscodeEncoding,\n  atob,\n  btoa,\n  constants,\n  isAscii,\n  isUtf8,\n  kMaxLength,\n  kStringMaxLength,\n  resolveObjectURL,\n  transcode,\n// eslint-disable-next-line unicorn/prefer-node-protocol\n} from 'buffer'\n\nexport {\n  Blob,\n  BlobOptions,\n  Buffer,\n  File,\n  FileOptions,\n  INSPECT_MAX_BYTES,\n  SlowBuffer,\n  TranscodeEncoding,\n  atob,\n  btoa,\n  constants,\n  isAscii,\n  isUtf8,\n  kMaxLength,\n  kStringMaxLength,\n  resolveObjectURL,\n  transcode,\n}\n\nexport default Buffer\n", "/**\n * Global Polyfills Setup\n * Must be imported first, before any other modules that depend on Node.js globals\n */\nimport { sha512 } from '@noble/hashes/sha512';\nimport { ed25519 } from '@noble/curves/ed25519';\n\nif (!(ed25519.utils as any).sha512Sync) {\n  (ed25519.utils as any).sha512Sync = sha512;\n  console.log('[✅] ed25519.utils.sha512Sync has been set in globalPolyfills');\n} else {\n  console.log('[🟡] ed25519.utils.sha512Sync was already set');\n}\n\nimport { Buffer } from 'buffer';\n\n// Ensure process is available early\nif (typeof globalThis.process === 'undefined') {\n  globalThis.process = {\n    env: typeof process !== 'undefined' ? process.env : {},\n    nextTick: (fn: Function, ...args: any[]) => setTimeout(() => fn(...args), 0),\n    version: '16.0.0',\n    platform: 'browser',\n    browser: true,\n    argv: [],\n    cwd: () => '/',\n    versions: {\n      node: '16.0.0'\n    }\n  } as any;\n}\n\n// Ensure global is available early\nif (typeof globalThis.global === 'undefined') {\n  globalThis.global = globalThis;\n}\n\n// Set Buffer with additional safety checks\nif (typeof globalThis.Buffer === 'undefined') {\n  globalThis.Buffer = Buffer;\n}\n\n// Ensure window globals for browser\nif (typeof window !== 'undefined') {\n  // Set Buffer on window immediately\n  (window as any).Buffer = Buffer;\n  (window as any).global = globalThis;\n  \n  // Set up process on window\n  if (!(window as any).process) {\n    (window as any).process = globalThis.process;\n  }\n}\n\n// Additional crypto-browserify compatibility\nif (typeof globalThis !== 'undefined') {\n  // Ensure Buffer is always the imported one\n  (globalThis as any).Buffer = Buffer;\n  (globalThis as any).global = globalThis;\n}\n\n// Ensure setImmediate is available\nif (typeof globalThis.setImmediate === 'undefined') {\n  (globalThis as any).setImmediate = (fn: Function, ...args: any[]) => {\n    return setTimeout(() => fn(...args), 0);\n  };\n  (globalThis as any).clearImmediate = (id: any) => clearTimeout(id);\n}\n\n// Ensure crypto compatibility\nif (typeof globalThis.crypto === 'undefined' && typeof window !== 'undefined' && window.crypto) {\n  globalThis.crypto = window.crypto;\n}\n\n// Log successful initialization in development\nif (typeof window !== 'undefined' && typeof console !== 'undefined') {\n  console.debug('Global polyfills initialized');\n  console.debug('Buffer available:', typeof globalThis.Buffer !== 'undefined');\n  console.debug('Buffer.slice available:', typeof globalThis.Buffer?.prototype?.slice === 'function');\n}\n\nexport {};\n", "/**\n * SHA2-512 a.k.a. sha512 and sha384. It is slower than sha256 in js because u64 operations are slow.\n *\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [the paper on truncated SHA512/256](https://eprint.iacr.org/2010/548.pdf).\n * @module\n * @deprecated\n */\nimport {\n  SHA384 as SHA384n,\n  sha384 as sha384n,\n  sha512_224 as sha512_224n,\n  SHA512_224 as SHA512_224n,\n  sha512_256 as sha512_256n,\n  SHA512_256 as SHA512_256n,\n  SHA512 as SHA512n,\n  sha512 as sha512n,\n} from './sha2.ts';\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA512: typeof SHA512n = SHA512n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha512: typeof sha512n = sha512n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA384: typeof SHA384n = SHA384n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha384: typeof sha384n = sha384n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA512_224: typeof SHA512_224n = SHA512_224n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha512_224: typeof sha512_224n = sha512_224n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA512_256: typeof SHA512_256n = SHA512_256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha512_256: typeof sha512_256n = sha512_256n;\n"],
  "mappings": "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",
  "names": ["base64Js", "byteLength", "toByteArray", "fromByteArray", "lookup", "revLookup", "Arr", "code", "getLens", "len", "_byteLength", "i", "tripletToBase64", "encodeChunk", "len2", "ieee754", "buffer", "isLE", "require$$0", "require$$1", "exports", "Buffer", "SlowBuffer", "utf8ToBytes", "process", "browserModule", "e", "import_dist", "import_dist", "isLE", "_32n", "import_dist", "buffer", "import_dist", "import_dist", "import_dist", "init_utils", "_0n", "_1n", "Fp", "isLE", "import_dist", "init_utils", "window", "_1n", "_0n", "wbits", "Fp", "import_dist", "init_utils", "Fp", "_2n", "_1n", "uvRatio", "_0n", "_8n", "adjustScalarBytes", "eddsa", "import_dist", "init_utils", "createHasher", "import_dist", "init_utils", "adjustScalarBytes", "_2n", "_1n", "_0n", "import_dist", "init_utils", "_2n", "_1n", "_5n", "_8n", "mod", "import_dist", "_0n", "_3n", "init_utils", "createHasher", "Buffer", "buffer", "isLE", "require$$0", "ieee754", "require$$1", "SlowBuffer", "byteLength", "utf8ToBytes", "i", "code", "sha512", "import_dist", "SHA512", "sha512", "SHA384", "sha384", "SHA512_224", "sha512_224", "SHA512_256", "sha512_256"]
}
