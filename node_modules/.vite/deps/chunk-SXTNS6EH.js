import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  AppKitBaseClient
} from "./chunk-HO7F4MGR.js";
import {
  W3mFrameHelpers,
  W3mFrameProvider
} from "./chunk-5LF73QIQ.js";
import {
  ConstantsUtil as ConstantsUtil3,
  ErrorUtil,
  HelpersUtil,
  ProviderUtil
} from "./chunk-F5BLFGNY.js";
import {
  AccountController,
  AlertController,
  ApiController,
  ChainController,
  ConnectionController,
  ConnectorController,
  ConstantsUtil,
  ConstantsUtil2,
  CoreHelperUtil,
  EventsController,
  OptionsController,
  PublicStateController,
  StorageUtil,
  ThemeController,
  W3mFrameRpcConstants,
  getW3mThemeVariables
} from "./chunk-C5LFNDH4.js";
import {
  __toESM,
  init_globalPolyfills,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-F62UFKTJ.js";

// node_modules/.pnpm/@reown+appkit@1.7.8_@types+react@18.3.23_bufferutil@4.0.9_react@18.3.1_typescript@5.8.3_5cc87f27141f63e121be55d99aa28f0e/node_modules/@reown/appkit/dist/esm/src/client/appkit.js
init_globalPolyfills();
var import_dist4 = __toESM(require_dist(), 1);
var import_dist5 = __toESM(require_dist2(), 1);
var import_dist6 = __toESM(require_dist3(), 1);

// node_modules/.pnpm/@reown+appkit@1.7.8_@types+react@18.3.23_bufferutil@4.0.9_react@18.3.1_typescript@5.8.3_5cc87f27141f63e121be55d99aa28f0e/node_modules/@reown/appkit/dist/esm/src/auth-provider/W3MFrameProviderSingleton.js
init_globalPolyfills();
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);
var W3mFrameProviderSingleton = class _W3mFrameProviderSingleton {
  // eslint-disable-next-line @typescript-eslint/no-empty-function -- This is a singleton
  constructor() {
  }
  static getInstance({ projectId, chainId, enableLogger, onTimeout, abortController }) {
    if (!_W3mFrameProviderSingleton.instance) {
      _W3mFrameProviderSingleton.instance = new W3mFrameProvider({
        projectId,
        chainId,
        enableLogger,
        onTimeout,
        abortController
      });
    }
    return _W3mFrameProviderSingleton.instance;
  }
};

// node_modules/.pnpm/@reown+appkit@1.7.8_@types+react@18.3.23_bufferutil@4.0.9_react@18.3.1_typescript@5.8.3_5cc87f27141f63e121be55d99aa28f0e/node_modules/@reown/appkit/dist/esm/src/client/appkit.js
var isInitialized = false;
var AppKit = class extends AppKitBaseClient {
  // -- Private ------------------------------------------------------------------
  setupAuthConnectorListeners(provider) {
    provider.onRpcRequest((request) => {
      if (W3mFrameHelpers.checkIfRequestExists(request)) {
        if (!W3mFrameHelpers.checkIfRequestIsSafe(request)) {
          this.handleUnsafeRPCRequest();
        }
      } else {
        this.open();
        console.error(W3mFrameRpcConstants.RPC_METHOD_NOT_ALLOWED_MESSAGE, {
          method: request.method
        });
        setTimeout(() => {
          this.showErrorMessage(W3mFrameRpcConstants.RPC_METHOD_NOT_ALLOWED_UI_MESSAGE);
        }, 300);
        provider.rejectRpcRequests();
      }
    });
    provider.onRpcError(() => {
      const isModalOpen = this.isOpen();
      if (isModalOpen) {
        if (this.isTransactionStackEmpty()) {
          this.close();
        } else {
          this.popTransactionStack("error");
        }
      }
    });
    provider.onRpcSuccess((_, request) => {
      const isSafeRequest = W3mFrameHelpers.checkIfRequestIsSafe(request);
      const address = AccountController.state.address;
      const caipNetwork = ChainController.state.activeCaipNetwork;
      if (isSafeRequest) {
        return;
      }
      if (address && caipNetwork?.id) {
        this.updateNativeBalance(address, caipNetwork.id, caipNetwork.chainNamespace);
      }
      if (this.isTransactionStackEmpty()) {
        this.close();
      } else {
        this.popTransactionStack("success");
      }
    });
    provider.onNotConnected(() => {
      const namespace = ChainController.state.activeChain;
      const connectorId = ConnectorController.getConnectorId(namespace);
      const isConnectedWithAuth = connectorId === ConstantsUtil.CONNECTOR_ID.AUTH;
      if (isConnectedWithAuth) {
        this.setCaipAddress(void 0, namespace);
        this.setLoading(false, namespace);
      }
    });
    provider.onConnect((user) => {
      const namespace = ChainController.state.activeChain;
      const caipAddress = namespace === ConstantsUtil.CHAIN.EVM ? `eip155:${user.chainId}:${user.address}` : `${user.chainId}:${user.address}`;
      const defaultAccountType = OptionsController.state.defaultAccountTypes[namespace];
      const currentAccountType = AccountController.state.preferredAccountTypes?.[namespace];
      const preferredAccountType = user.preferredAccountType || currentAccountType || defaultAccountType;
      if (!HelpersUtil.isLowerCaseMatch(user.address, AccountController.state.address)) {
        this.syncIdentity({
          address: user.address,
          chainId: user.chainId,
          chainNamespace: namespace
        });
      }
      this.setCaipAddress(caipAddress, namespace);
      this.setUser({ ...AccountController.state.user || {}, ...user }, namespace);
      this.setSmartAccountDeployed(Boolean(user.smartAccountDeployed), namespace);
      this.setPreferredAccountType(preferredAccountType, namespace);
      const userAccounts = user.accounts?.map((account) => CoreHelperUtil.createAccount(namespace, account.address, account.type || currentAccountType || defaultAccountType));
      this.setAllAccounts(userAccounts || [
        CoreHelperUtil.createAccount(namespace, user.address, user.preferredAccountType || preferredAccountType)
      ], namespace);
      this.setLoading(false, namespace);
    });
    provider.onSocialConnected(({ userName }) => {
      this.setUser({ ...AccountController.state.user || {}, username: userName }, ChainController.state.activeChain);
    });
    provider.onGetSmartAccountEnabledNetworks((networks) => {
      this.setSmartAccountEnabledNetworks(networks, ChainController.state.activeChain);
    });
    provider.onSetPreferredAccount(({ address, type }) => {
      if (!address) {
        return;
      }
      this.setPreferredAccountType(type, ChainController.state.activeChain);
    });
  }
  async syncAuthConnector(provider, chainNamespace) {
    const isAuthSupported = ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(chainNamespace);
    if (!isAuthSupported) {
      return;
    }
    this.setLoading(true, chainNamespace);
    const isLoginEmailUsed = provider.getLoginEmailUsed();
    this.setLoading(isLoginEmailUsed, chainNamespace);
    if (isLoginEmailUsed) {
      this.setStatus("connecting", chainNamespace);
    }
    const email = provider.getEmail();
    const username = provider.getUsername();
    this.setUser({ ...AccountController.state?.user || {}, username, email }, chainNamespace);
    this.setupAuthConnectorListeners(provider);
    const { isConnected } = await provider.isConnected();
    const theme = ThemeController.getSnapshot();
    const options = OptionsController.getSnapshot();
    await Promise.all([
      provider.syncDappData({
        metadata: options.metadata,
        sdkVersion: options.sdkVersion,
        projectId: options.projectId,
        sdkType: options.sdkType
      }),
      provider.syncTheme({
        themeMode: theme.themeMode,
        themeVariables: theme.themeVariables,
        w3mThemeVariables: getW3mThemeVariables(theme.themeVariables, theme.themeMode)
      })
    ]);
    await provider.getSmartAccountEnabledNetworks();
    if (chainNamespace && isAuthSupported) {
      if (isConnected && this.connectionControllerClient?.connectExternal) {
        await this.connectionControllerClient?.connectExternal({
          id: ConstantsUtil.CONNECTOR_ID.AUTH,
          info: { name: ConstantsUtil.CONNECTOR_ID.AUTH },
          type: ConstantsUtil3.CONNECTOR_TYPE_AUTH,
          provider,
          chainId: ChainController.state.activeCaipNetwork?.id,
          chain: chainNamespace
        });
        this.setStatus("connected", chainNamespace);
      } else if (ConnectorController.getConnectorId(chainNamespace) === ConstantsUtil.CONNECTOR_ID.AUTH) {
        this.setStatus("disconnected", chainNamespace);
        StorageUtil.removeConnectedNamespace(chainNamespace);
      }
    }
    this.setLoading(false, chainNamespace);
  }
  async checkExistingTelegramSocialConnection(chainNamespace) {
    try {
      if (!CoreHelperUtil.isTelegram()) {
        return;
      }
      const socialProviderToConnect = StorageUtil.getTelegramSocialProvider();
      if (!socialProviderToConnect) {
        return;
      }
      if (!CoreHelperUtil.isClient()) {
        return;
      }
      const url = new URL(window.location.href);
      const resultUri = url.searchParams.get("result_uri");
      if (!resultUri) {
        return;
      }
      AccountController.setSocialProvider(socialProviderToConnect, chainNamespace);
      await this.authProvider?.init();
      const authConnector = ConnectorController.getAuthConnector();
      if (socialProviderToConnect && authConnector) {
        this.setLoading(true, chainNamespace);
        await ConnectionController.connectExternal({
          id: authConnector.id,
          type: authConnector.type,
          socialUri: resultUri
        }, authConnector.chain);
        StorageUtil.setConnectedSocialProvider(socialProviderToConnect);
        StorageUtil.removeTelegramSocialProvider();
        EventsController.sendEvent({
          type: "track",
          event: "SOCIAL_LOGIN_SUCCESS",
          properties: { provider: socialProviderToConnect }
        });
      }
    } catch (error) {
      this.setLoading(false, chainNamespace);
      console.error("checkExistingSTelegramocialConnection error", error);
    }
    try {
      const url = new URL(window.location.href);
      url.searchParams.delete("result_uri");
      window.history.replaceState({}, document.title, url.toString());
    } catch (error) {
      console.error("tma social login failed", error);
    }
  }
  createAuthProvider(chainNamespace) {
    const isSupported = ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(chainNamespace);
    if (!isSupported) {
      return;
    }
    const isEmailEnabled = this.remoteFeatures?.email;
    const isSocialsEnabled = Array.isArray(this.remoteFeatures?.socials) && this.remoteFeatures.socials.length > 0;
    const isAuthEnabled = isEmailEnabled || isSocialsEnabled;
    if (!this.authProvider && this.options?.projectId && isAuthEnabled) {
      this.authProvider = W3mFrameProviderSingleton.getInstance({
        projectId: this.options.projectId,
        enableLogger: this.options.enableAuthLogger,
        chainId: this.getCaipNetwork(chainNamespace)?.caipNetworkId,
        abortController: ErrorUtil.EmbeddedWalletAbortController,
        onTimeout: (reason) => {
          if (reason === "iframe_load_failed") {
            AlertController.open(ErrorUtil.ALERT_ERRORS.IFRAME_LOAD_FAILED, "error");
          } else if (reason === "iframe_request_timeout") {
            AlertController.open(ErrorUtil.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT, "error");
          } else if (reason === "unverified_domain") {
            AlertController.open(ErrorUtil.ALERT_ERRORS.UNVERIFIED_DOMAIN, "error");
          }
        }
      });
      PublicStateController.subscribeOpen((isOpen) => {
        if (!isOpen && this.isTransactionStackEmpty()) {
          this.authProvider?.rejectRpcRequests();
        }
      });
      this.syncAuthConnector(this.authProvider, chainNamespace);
      this.checkExistingTelegramSocialConnection(chainNamespace);
    }
  }
  createAuthProviderForAdapter(chainNamespace) {
    this.createAuthProvider(chainNamespace);
    if (this.authProvider) {
      this.chainAdapters?.[chainNamespace]?.setAuthProvider?.(this.authProvider);
    }
  }
  // -- Overrides ----------------------------------------------------------------
  initControllers(options) {
    super.initControllers(options);
    if (this.options.excludeWalletIds) {
      ApiController.initializeExcludedWallets({ ids: this.options.excludeWalletIds });
    }
  }
  async switchCaipNetwork(caipNetwork) {
    if (!caipNetwork) {
      return;
    }
    const currentNamespace = ChainController.state.activeChain;
    const networkNamespace = caipNetwork.chainNamespace;
    const namespaceAddress = this.getAddressByChainNamespace(networkNamespace);
    const isSameNamespace = networkNamespace === currentNamespace;
    if (isSameNamespace && namespaceAddress) {
      const adapter = this.getAdapter(networkNamespace);
      const provider = ProviderUtil.getProvider(networkNamespace);
      const providerType = ProviderUtil.getProviderId(networkNamespace);
      await adapter?.switchNetwork({ caipNetwork, provider, providerType });
      this.setCaipNetwork(caipNetwork);
    } else {
      const currentNamespaceProviderType = ProviderUtil.getProviderId(currentNamespace);
      const isCurrentNamespaceAuthProvider = currentNamespaceProviderType === ConstantsUtil3.CONNECTOR_TYPE_AUTH;
      const newNamespaceProviderType = ProviderUtil.getProviderId(networkNamespace);
      const isNewNamespaceAuthProvider = newNamespaceProviderType === ConstantsUtil3.CONNECTOR_TYPE_AUTH;
      const isNewNamespaceSupportsAuthConnector = ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.includes(networkNamespace);
      if ((isCurrentNamespaceAuthProvider && newNamespaceProviderType === void 0 || isNewNamespaceAuthProvider) && isNewNamespaceSupportsAuthConnector) {
        try {
          ChainController.state.activeChain = caipNetwork.chainNamespace;
          if (namespaceAddress) {
            const adapter = this.getAdapter(networkNamespace);
            await adapter?.switchNetwork({
              caipNetwork,
              provider: this.authProvider,
              providerType: newNamespaceProviderType
            });
          } else {
            await this.connectionControllerClient?.connectExternal?.({
              id: ConstantsUtil.CONNECTOR_ID.AUTH,
              provider: this.authProvider,
              chain: networkNamespace,
              chainId: caipNetwork.id,
              type: ConstantsUtil3.CONNECTOR_TYPE_AUTH,
              caipNetwork
            });
          }
          this.setCaipNetwork(caipNetwork);
        } catch (error) {
          const adapter = this.getAdapter(networkNamespace);
          await adapter?.switchNetwork({
            caipNetwork,
            provider: this.authProvider,
            providerType: newNamespaceProviderType
          });
        }
      } else if (newNamespaceProviderType === ConstantsUtil3.CONNECTOR_TYPE_WALLET_CONNECT) {
        this.setCaipNetwork(caipNetwork);
        this.syncWalletConnectAccount();
      } else {
        this.setCaipNetwork(caipNetwork);
        if (namespaceAddress) {
          this.syncAccount({
            address: namespaceAddress,
            chainId: caipNetwork.id,
            chainNamespace: networkNamespace
          });
        }
      }
    }
  }
  async initialize(options) {
    await super.initialize(options);
    this.chainNamespaces?.forEach((namespace) => {
      this.createAuthProviderForAdapter(namespace);
    });
    await this.injectModalUi();
    PublicStateController.set({ initialized: true });
  }
  async syncIdentity({ address, chainId, chainNamespace }) {
    const caipNetworkId = `${chainNamespace}:${chainId}`;
    const activeCaipNetwork = this.caipNetworks?.find((n) => n.caipNetworkId === caipNetworkId);
    if (chainNamespace !== ConstantsUtil.CHAIN.EVM || activeCaipNetwork?.testnet) {
      this.setProfileName(null, chainNamespace);
      this.setProfileImage(null, chainNamespace);
      return;
    }
    try {
      const { name, avatar } = await this.fetchIdentity({
        address,
        caipNetworkId
      });
      this.setProfileName(name, chainNamespace);
      this.setProfileImage(avatar, chainNamespace);
    } catch {
      await this.syncReownName(address, chainNamespace);
      if (chainId !== 1) {
        this.setProfileImage(null, chainNamespace);
      }
    }
  }
  syncConnectedWalletInfo(chainNamespace) {
    const providerType = ProviderUtil.getProviderId(chainNamespace);
    if (providerType === ConstantsUtil3.CONNECTOR_TYPE_AUTH) {
      const provider = this.authProvider;
      if (provider) {
        const social = StorageUtil.getConnectedSocialProvider() ?? "email";
        const identifier = provider.getEmail() ?? provider.getUsername();
        this.setConnectedWalletInfo({ name: providerType, identifier, social }, chainNamespace);
      }
    } else {
      super.syncConnectedWalletInfo(chainNamespace);
    }
  }
  async injectModalUi() {
    if (!CoreHelperUtil.isClient()) {
      return;
    }
    if (!isInitialized) {
      try {
        const features = { ...ConstantsUtil2.DEFAULT_FEATURES, ...this.options.features };
        const remoteFeatures = this.remoteFeatures;
        await this.loadModalComponents(features, remoteFeatures);
        if (CoreHelperUtil.isClient()) {
          const isElementCreated = document.querySelector("w3m-modal");
          if (!isElementCreated) {
            const modal = document.createElement("w3m-modal");
            if (!OptionsController.state.disableAppend && !OptionsController.state.enableEmbedded) {
              document.body.insertAdjacentElement("beforeend", modal);
            }
          }
        }
        isInitialized = true;
      } catch (error) {
        console.error("Error injecting modal UI:", error);
      }
    }
  }
  // This separate method helps with tree-shaking for SSR builds
  async loadModalComponents(features, remoteFeatures) {
    if (!CoreHelperUtil.isClient()) {
      return;
    }
    const featureImportPromises = [];
    const usingEmbeddedWallet = remoteFeatures.email || remoteFeatures.socials && remoteFeatures.socials.length > 0;
    if (usingEmbeddedWallet) {
      featureImportPromises.push(import("./embedded-wallet-MZMMNNYN.js"));
    }
    if (remoteFeatures.email) {
      featureImportPromises.push(import("./email-2F3RDIKQ.js"));
    }
    if (remoteFeatures.socials) {
      featureImportPromises.push(import("./socials-WVFOA277.js"));
    }
    if (remoteFeatures.swaps && remoteFeatures.swaps.length > 0) {
      featureImportPromises.push(import("./swaps-YZ7M2ITJ.js"));
    }
    if (features.send) {
      featureImportPromises.push(import("./send-DLED3N3V.js"));
    }
    if (features.receive) {
      featureImportPromises.push(import("./receive-V2EOFCQP.js"));
    }
    if (remoteFeatures.onramp && remoteFeatures.onramp.length > 0) {
      featureImportPromises.push(import("./onramp-N2RGTRTX.js"));
    }
    if (remoteFeatures.activity) {
      featureImportPromises.push(import("./transactions-UMMF5Y4E.js"));
    }
    if (features.pay) {
      featureImportPromises.push(import("./exports-6GADACKW.js"));
    }
    await Promise.all([
      ...featureImportPromises,
      import("./exports-XYCJ7OGJ.js"),
      import("./w3m-modal-BNMSHB3W.js")
    ]);
  }
};

export {
  W3mFrameProviderSingleton,
  AppKit
};
//# sourceMappingURL=chunk-SXTNS6EH.js.map
