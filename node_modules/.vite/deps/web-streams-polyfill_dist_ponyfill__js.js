import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  __commonJS,
  __toESM,
  init_globalPolyfills,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-F62UFKTJ.js";

// node_modules/.pnpm/web-streams-polyfill@4.1.0/node_modules/web-streams-polyfill/dist/ponyfill.js
var require_ponyfill = __commonJS({
  "node_modules/.pnpm/web-streams-polyfill@4.1.0/node_modules/web-streams-polyfill/dist/ponyfill.js"(exports, module) {
    init_globalPolyfills();
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).WebStreamsPolyfill = {});
    }(exports, function(e) {
      "use strict";
      function t() {
      }
      function r(e2) {
        return "object" == typeof e2 && null !== e2 || "function" == typeof e2;
      }
      const o = t;
      function n(e2, t2) {
        try {
          Object.defineProperty(e2, "name", { value: t2, configurable: true });
        } catch (e3) {
        }
      }
      const a = Promise, i = Promise.resolve.bind(a), l = Promise.prototype.then, s = Promise.reject.bind(a), u = i;
      function c(e2) {
        return new a(e2);
      }
      function d(e2) {
        return c((t2) => t2(e2));
      }
      function f(e2) {
        return s(e2);
      }
      function b(e2, t2, r2) {
        return l.call(e2, t2, r2);
      }
      function h(e2, t2, r2) {
        b(b(e2, t2, r2), void 0, o);
      }
      function m(e2, t2) {
        h(e2, t2);
      }
      function _(e2, t2) {
        h(e2, void 0, t2);
      }
      function p(e2, t2, r2) {
        return b(e2, t2, r2);
      }
      function y(e2) {
        b(e2, void 0, o);
      }
      let S = (e2) => {
        if ("function" == typeof queueMicrotask) S = queueMicrotask;
        else {
          const e3 = d(void 0);
          S = (t2) => b(e3, t2);
        }
        return S(e2);
      };
      function g(e2, t2, r2) {
        if ("function" != typeof e2) throw new TypeError("Argument is not a function");
        return Function.prototype.apply.call(e2, t2, r2);
      }
      function v(e2, t2, r2) {
        try {
          return d(g(e2, t2, r2));
        } catch (e3) {
          return f(e3);
        }
      }
      class w {
        constructor() {
          this._cursor = 0, this._size = 0, this._front = { _elements: [], _next: void 0 }, this._back = this._front, this._cursor = 0, this._size = 0;
        }
        get length() {
          return this._size;
        }
        push(e2) {
          const t2 = this._back;
          let r2 = t2;
          16383 === t2._elements.length && (r2 = { _elements: [], _next: void 0 }), t2._elements.push(e2), r2 !== t2 && (this._back = r2, t2._next = r2), ++this._size;
        }
        shift() {
          const e2 = this._front;
          let t2 = e2;
          const r2 = this._cursor;
          let o2 = r2 + 1;
          const n2 = e2._elements, a2 = n2[r2];
          return 16384 === o2 && (t2 = e2._next, o2 = 0), --this._size, this._cursor = o2, e2 !== t2 && (this._front = t2), n2[r2] = void 0, a2;
        }
        forEach(e2) {
          let t2 = this._cursor, r2 = this._front, o2 = r2._elements;
          for (; !(t2 === o2.length && void 0 === r2._next || t2 === o2.length && (r2 = r2._next, o2 = r2._elements, t2 = 0, 0 === o2.length)); ) e2(o2[t2]), ++t2;
        }
        peek() {
          const e2 = this._front, t2 = this._cursor;
          return e2._elements[t2];
        }
      }
      const R = Symbol("[[AbortSteps]]"), T = Symbol("[[ErrorSteps]]"), C = Symbol("[[CancelSteps]]"), P = Symbol("[[PullSteps]]"), q = Symbol("[[ReleaseSteps]]");
      function E(e2, t2) {
        e2._ownerReadableStream = t2, t2._reader = e2, "readable" === t2._state ? j(e2) : "closed" === t2._state ? function(e3) {
          j(e3), z(e3);
        }(e2) : k(e2, t2._storedError);
      }
      function W(e2, t2) {
        return Or(e2._ownerReadableStream, t2);
      }
      function B(e2) {
        const t2 = e2._ownerReadableStream;
        "readable" === t2._state ? A(e2, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : function(e3, t3) {
          k(e3, t3);
        }(e2, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), t2._readableStreamController[q](), t2._reader = void 0, e2._ownerReadableStream = void 0;
      }
      function O(e2) {
        return new TypeError("Cannot " + e2 + " a stream using a released reader");
      }
      function j(e2) {
        e2._closedPromise = c((t2, r2) => {
          e2._closedPromise_resolve = t2, e2._closedPromise_reject = r2;
        });
      }
      function k(e2, t2) {
        j(e2), A(e2, t2);
      }
      function A(e2, t2) {
        void 0 !== e2._closedPromise_reject && (y(e2._closedPromise), e2._closedPromise_reject(t2), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0);
      }
      function z(e2) {
        void 0 !== e2._closedPromise_resolve && (e2._closedPromise_resolve(void 0), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0);
      }
      const D = Number.isFinite || function(e2) {
        return "number" == typeof e2 && isFinite(e2);
      }, L = Math.trunc || function(e2) {
        return e2 < 0 ? Math.ceil(e2) : Math.floor(e2);
      };
      function F(e2, t2) {
        if (void 0 !== e2 && ("object" != typeof (r2 = e2) && "function" != typeof r2)) throw new TypeError(`${t2} is not an object.`);
        var r2;
      }
      function I(e2, t2) {
        if ("function" != typeof e2) throw new TypeError(`${t2} is not a function.`);
      }
      function $(e2, t2) {
        if (!/* @__PURE__ */ function(e3) {
          return "object" == typeof e3 && null !== e3 || "function" == typeof e3;
        }(e2)) throw new TypeError(`${t2} is not an object.`);
      }
      function M(e2, t2, r2) {
        if (void 0 === e2) throw new TypeError(`Parameter ${t2} is required in '${r2}'.`);
      }
      function Y(e2, t2, r2) {
        if (void 0 === e2) throw new TypeError(`${t2} is required in '${r2}'.`);
      }
      function x(e2) {
        return Number(e2);
      }
      function Q(e2) {
        return 0 === e2 ? 0 : e2;
      }
      function N(e2, t2) {
        const r2 = Number.MAX_SAFE_INTEGER;
        let o2 = Number(e2);
        if (o2 = Q(o2), !D(o2)) throw new TypeError(`${t2} is not a finite number`);
        if (o2 = function(e3) {
          return Q(L(e3));
        }(o2), o2 < 0 || o2 > r2) throw new TypeError(`${t2} is outside the accepted range of 0 to ${r2}, inclusive`);
        return D(o2) && 0 !== o2 ? o2 : 0;
      }
      function H(e2, t2) {
        if (!Wr(e2)) throw new TypeError(`${t2} is not a ReadableStream.`);
      }
      function V(e2) {
        return new ReadableStreamDefaultReader(e2);
      }
      function U(e2, t2) {
        e2._reader._readRequests.push(t2);
      }
      function G(e2, t2, r2) {
        const o2 = e2._reader._readRequests.shift();
        r2 ? o2._closeSteps() : o2._chunkSteps(t2);
      }
      function X(e2) {
        return e2._reader._readRequests.length;
      }
      function J(e2) {
        const t2 = e2._reader;
        return void 0 !== t2 && !!K(t2);
      }
      class ReadableStreamDefaultReader {
        constructor(e2) {
          if (M(e2, 1, "ReadableStreamDefaultReader"), H(e2, "First parameter"), Br(e2)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          E(this, e2), this._readRequests = new w();
        }
        get closed() {
          return K(this) ? this._closedPromise : f(te("closed"));
        }
        cancel(e2 = void 0) {
          return K(this) ? void 0 === this._ownerReadableStream ? f(O("cancel")) : W(this, e2) : f(te("cancel"));
        }
        read() {
          if (!K(this)) return f(te("read"));
          if (void 0 === this._ownerReadableStream) return f(O("read from"));
          let e2, t2;
          const r2 = c((r3, o2) => {
            e2 = r3, t2 = o2;
          });
          return Z(this, { _chunkSteps: (t3) => e2({ value: t3, done: false }), _closeSteps: () => e2({ value: void 0, done: true }), _errorSteps: (e3) => t2(e3) }), r2;
        }
        releaseLock() {
          if (!K(this)) throw te("releaseLock");
          void 0 !== this._ownerReadableStream && function(e2) {
            B(e2);
            const t2 = new TypeError("Reader was released");
            ee(e2, t2);
          }(this);
        }
      }
      function K(e2) {
        return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_readRequests") && e2 instanceof ReadableStreamDefaultReader);
      }
      function Z(e2, t2) {
        const r2 = e2._ownerReadableStream;
        r2._disturbed = true, "closed" === r2._state ? t2._closeSteps() : "errored" === r2._state ? t2._errorSteps(r2._storedError) : r2._readableStreamController[P](t2);
      }
      function ee(e2, t2) {
        const r2 = e2._readRequests;
        e2._readRequests = new w(), r2.forEach((e3) => {
          e3._errorSteps(t2);
        });
      }
      function te(e2) {
        return new TypeError(`ReadableStreamDefaultReader.prototype.${e2} can only be used on a ReadableStreamDefaultReader`);
      }
      var re, oe, ne;
      function ae(e2) {
        return e2.slice();
      }
      function ie(e2, t2, r2, o2, n2) {
        new Uint8Array(e2).set(new Uint8Array(r2, o2, n2), t2);
      }
      Object.defineProperties(ReadableStreamDefaultReader.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), n(ReadableStreamDefaultReader.prototype.cancel, "cancel"), n(ReadableStreamDefaultReader.prototype.read, "read"), n(ReadableStreamDefaultReader.prototype.releaseLock, "releaseLock"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, { value: "ReadableStreamDefaultReader", configurable: true });
      let le = (e2) => (le = "function" == typeof e2.transfer ? (e3) => e3.transfer() : "function" == typeof structuredClone ? (e3) => structuredClone(e3, { transfer: [e3] }) : (e3) => e3, le(e2)), se = (e2) => (se = "boolean" == typeof e2.detached ? (e3) => e3.detached : (e3) => 0 === e3.byteLength, se(e2));
      function ue(e2, t2, r2) {
        if (e2.slice) return e2.slice(t2, r2);
        const o2 = r2 - t2, n2 = new ArrayBuffer(o2);
        return ie(n2, 0, e2, t2, o2), n2;
      }
      function ce(e2, t2) {
        const r2 = e2[t2];
        if (null != r2) {
          if ("function" != typeof r2) throw new TypeError(`${String(t2)} is not a function`);
          return r2;
        }
      }
      function de(e2) {
        try {
          const t2 = e2.done, r2 = e2.value;
          return b(u(r2), (e3) => ({ done: t2, value: e3 }));
        } catch (e3) {
          return f(e3);
        }
      }
      const fe = null !== (ne = null !== (re = Symbol.asyncIterator) && void 0 !== re ? re : null === (oe = Symbol.for) || void 0 === oe ? void 0 : oe.call(Symbol, "Symbol.asyncIterator")) && void 0 !== ne ? ne : "@@asyncIterator";
      function be(e2, t2 = "sync", o2) {
        if (void 0 === o2) if ("async" === t2) {
          if (void 0 === (o2 = ce(e2, fe))) {
            return function(e3) {
              const t3 = { next() {
                let t4;
                try {
                  t4 = he(e3);
                } catch (e4) {
                  return f(e4);
                }
                return de(t4);
              }, return(t4) {
                let o3;
                try {
                  const r2 = ce(e3.iterator, "return");
                  if (void 0 === r2) return d({ done: true, value: t4 });
                  o3 = g(r2, e3.iterator, [t4]);
                } catch (e4) {
                  return f(e4);
                }
                return r(o3) ? de(o3) : f(new TypeError("The iterator.return() method must return an object"));
              } };
              return { iterator: t3, nextMethod: t3.next, done: false };
            }(be(e2, "sync", ce(e2, Symbol.iterator)));
          }
        } else o2 = ce(e2, Symbol.iterator);
        if (void 0 === o2) throw new TypeError("The object is not iterable");
        const n2 = g(o2, e2, []);
        if (!r(n2)) throw new TypeError("The iterator method must return an object");
        return { iterator: n2, nextMethod: n2.next, done: false };
      }
      function he(e2) {
        const t2 = g(e2.nextMethod, e2.iterator, []);
        if (!r(t2)) throw new TypeError("The iterator.next() method must return an object");
        return t2;
      }
      class me {
        constructor(e2, t2) {
          this._ongoingPromise = void 0, this._isFinished = false, this._reader = e2, this._preventCancel = t2;
        }
        next() {
          const e2 = () => this._nextSteps();
          return this._ongoingPromise = this._ongoingPromise ? p(this._ongoingPromise, e2, e2) : e2(), this._ongoingPromise;
        }
        return(e2) {
          const t2 = () => this._returnSteps(e2);
          return this._ongoingPromise = this._ongoingPromise ? p(this._ongoingPromise, t2, t2) : t2(), this._ongoingPromise;
        }
        _nextSteps() {
          if (this._isFinished) return Promise.resolve({ value: void 0, done: true });
          const e2 = this._reader;
          let t2, r2;
          const o2 = c((e3, o3) => {
            t2 = e3, r2 = o3;
          });
          return Z(e2, { _chunkSteps: (e3) => {
            this._ongoingPromise = void 0, S(() => t2({ value: e3, done: false }));
          }, _closeSteps: () => {
            this._ongoingPromise = void 0, this._isFinished = true, B(e2), t2({ value: void 0, done: true });
          }, _errorSteps: (t3) => {
            this._ongoingPromise = void 0, this._isFinished = true, B(e2), r2(t3);
          } }), o2;
        }
        _returnSteps(e2) {
          if (this._isFinished) return Promise.resolve({ value: e2, done: true });
          this._isFinished = true;
          const t2 = this._reader;
          if (!this._preventCancel) {
            const r2 = W(t2, e2);
            return B(t2), p(r2, () => ({ value: e2, done: true }));
          }
          return B(t2), d({ value: e2, done: true });
        }
      }
      const _e = { next() {
        return pe(this) ? this._asyncIteratorImpl.next() : f(ye("next"));
      }, return(e2) {
        return pe(this) ? this._asyncIteratorImpl.return(e2) : f(ye("return"));
      }, [fe]() {
        return this;
      } };
      function pe(e2) {
        if (!r(e2)) return false;
        if (!Object.prototype.hasOwnProperty.call(e2, "_asyncIteratorImpl")) return false;
        try {
          return e2._asyncIteratorImpl instanceof me;
        } catch (e3) {
          return false;
        }
      }
      function ye(e2) {
        return new TypeError(`ReadableStreamAsyncIterator.${e2} can only be used on a ReadableSteamAsyncIterator`);
      }
      Object.defineProperty(_e, fe, { enumerable: false });
      const Se = Number.isNaN || function(e2) {
        return e2 != e2;
      };
      function ge(e2) {
        const t2 = ue(e2.buffer, e2.byteOffset, e2.byteOffset + e2.byteLength);
        return new Uint8Array(t2);
      }
      function ve(e2) {
        const t2 = e2._queue.shift();
        return e2._queueTotalSize -= t2.size, e2._queueTotalSize < 0 && (e2._queueTotalSize = 0), t2.value;
      }
      function we(e2, t2, r2) {
        if ("number" != typeof (o2 = r2) || Se(o2) || o2 < 0 || r2 === 1 / 0) throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        var o2;
        e2._queue.push({ value: t2, size: r2 }), e2._queueTotalSize += r2;
      }
      function Re(e2) {
        e2._queue = new w(), e2._queueTotalSize = 0;
      }
      function Te(e2) {
        return e2 === DataView;
      }
      class ReadableStreamBYOBRequest {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get view() {
          if (!Pe(this)) throw Ze("view");
          return this._view;
        }
        respond(e2) {
          if (!Pe(this)) throw Ze("respond");
          if (M(e2, 1, "respond"), e2 = N(e2, "First parameter"), void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated");
          if (se(this._view.buffer)) throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");
          Xe(this._associatedReadableByteStreamController, e2);
        }
        respondWithNewView(e2) {
          if (!Pe(this)) throw Ze("respondWithNewView");
          if (M(e2, 1, "respondWithNewView"), !ArrayBuffer.isView(e2)) throw new TypeError("You can only respond with array buffer views");
          if (void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated");
          if (se(e2.buffer)) throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");
          Je(this._associatedReadableByteStreamController, e2);
        }
      }
      Object.defineProperties(ReadableStreamBYOBRequest.prototype, { respond: { enumerable: true }, respondWithNewView: { enumerable: true }, view: { enumerable: true } }), n(ReadableStreamBYOBRequest.prototype.respond, "respond"), n(ReadableStreamBYOBRequest.prototype.respondWithNewView, "respondWithNewView"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, { value: "ReadableStreamBYOBRequest", configurable: true });
      class ReadableByteStreamController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get byobRequest() {
          if (!Ce(this)) throw et("byobRequest");
          return Ue(this);
        }
        get desiredSize() {
          if (!Ce(this)) throw et("desiredSize");
          return Ge(this);
        }
        close() {
          if (!Ce(this)) throw et("close");
          if (this._closeRequested) throw new TypeError("The stream has already been closed; do not close it again!");
          const e2 = this._controlledReadableByteStream._state;
          if ("readable" !== e2) throw new TypeError(`The stream (in ${e2} state) is not in the readable state and cannot be closed`);
          Qe(this);
        }
        enqueue(e2) {
          if (!Ce(this)) throw et("enqueue");
          if (M(e2, 1, "enqueue"), !ArrayBuffer.isView(e2)) throw new TypeError("chunk must be an array buffer view");
          if (0 === e2.byteLength) throw new TypeError("chunk must have non-zero byteLength");
          if (0 === e2.buffer.byteLength) throw new TypeError("chunk's buffer must have non-zero byteLength");
          if (this._closeRequested) throw new TypeError("stream is closed or draining");
          const t2 = this._controlledReadableByteStream._state;
          if ("readable" !== t2) throw new TypeError(`The stream (in ${t2} state) is not in the readable state and cannot be enqueued to`);
          Ne(this, e2);
        }
        error(e2 = void 0) {
          if (!Ce(this)) throw et("error");
          He(this, e2);
        }
        [C](e2) {
          Ee(this), Re(this);
          const t2 = this._cancelAlgorithm(e2);
          return xe(this), t2;
        }
        [P](e2) {
          const t2 = this._controlledReadableByteStream;
          if (this._queueTotalSize > 0) return void Ve(this, e2);
          const r2 = this._autoAllocateChunkSize;
          if (void 0 !== r2) {
            let t3;
            try {
              t3 = new ArrayBuffer(r2);
            } catch (t4) {
              return void e2._errorSteps(t4);
            }
            const o2 = { buffer: t3, bufferByteLength: r2, byteOffset: 0, byteLength: r2, bytesFilled: 0, minimumFill: 1, elementSize: 1, viewConstructor: Uint8Array, readerType: "default" };
            this._pendingPullIntos.push(o2);
          }
          U(t2, e2), qe(this);
        }
        [q]() {
          if (this._pendingPullIntos.length > 0) {
            const e2 = this._pendingPullIntos.peek();
            e2.readerType = "none", this._pendingPullIntos = new w(), this._pendingPullIntos.push(e2);
          }
        }
      }
      function Ce(e2) {
        return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_controlledReadableByteStream") && e2 instanceof ReadableByteStreamController);
      }
      function Pe(e2) {
        return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_associatedReadableByteStreamController") && e2 instanceof ReadableStreamBYOBRequest);
      }
      function qe(e2) {
        const t2 = function(e3) {
          const t3 = e3._controlledReadableByteStream;
          if ("readable" !== t3._state) return false;
          if (e3._closeRequested) return false;
          if (!e3._started) return false;
          if (J(t3) && X(t3) > 0) return true;
          if (at(t3) && nt(t3) > 0) return true;
          const r2 = Ge(e3);
          if (r2 > 0) return true;
          return false;
        }(e2);
        if (!t2) return;
        if (e2._pulling) return void (e2._pullAgain = true);
        e2._pulling = true;
        h(e2._pullAlgorithm(), () => (e2._pulling = false, e2._pullAgain && (e2._pullAgain = false, qe(e2)), null), (t3) => (He(e2, t3), null));
      }
      function Ee(e2) {
        Fe(e2), e2._pendingPullIntos = new w();
      }
      function We(e2, t2) {
        let r2 = false;
        "closed" === e2._state && (r2 = true);
        const o2 = Oe(t2);
        "default" === t2.readerType ? G(e2, o2, r2) : function(e3, t3, r3) {
          const o3 = e3._reader, n2 = o3._readIntoRequests.shift();
          r3 ? n2._closeSteps(t3) : n2._chunkSteps(t3);
        }(e2, o2, r2);
      }
      function Be(e2, t2) {
        for (let r2 = 0; r2 < t2.length; ++r2) We(e2, t2[r2]);
      }
      function Oe(e2) {
        const t2 = e2.bytesFilled, r2 = e2.elementSize;
        return new e2.viewConstructor(e2.buffer, e2.byteOffset, t2 / r2);
      }
      function je(e2, t2, r2, o2) {
        e2._queue.push({ buffer: t2, byteOffset: r2, byteLength: o2 }), e2._queueTotalSize += o2;
      }
      function ke(e2, t2, r2, o2) {
        let n2;
        try {
          n2 = ue(t2, r2, r2 + o2);
        } catch (t3) {
          throw He(e2, t3), t3;
        }
        je(e2, n2, 0, o2);
      }
      function Ae(e2, t2) {
        t2.bytesFilled > 0 && ke(e2, t2.buffer, t2.byteOffset, t2.bytesFilled), Ye(e2);
      }
      function ze(e2, t2) {
        const r2 = Math.min(e2._queueTotalSize, t2.byteLength - t2.bytesFilled), o2 = t2.bytesFilled + r2;
        let n2 = r2, a2 = false;
        const i2 = o2 - o2 % t2.elementSize;
        i2 >= t2.minimumFill && (n2 = i2 - t2.bytesFilled, a2 = true);
        const l2 = e2._queue;
        for (; n2 > 0; ) {
          const r3 = l2.peek(), o3 = Math.min(n2, r3.byteLength), a3 = t2.byteOffset + t2.bytesFilled;
          ie(t2.buffer, a3, r3.buffer, r3.byteOffset, o3), r3.byteLength === o3 ? l2.shift() : (r3.byteOffset += o3, r3.byteLength -= o3), e2._queueTotalSize -= o3, De(e2, o3, t2), n2 -= o3;
        }
        return a2;
      }
      function De(e2, t2, r2) {
        r2.bytesFilled += t2;
      }
      function Le(e2) {
        0 === e2._queueTotalSize && e2._closeRequested ? (xe(e2), jr(e2._controlledReadableByteStream)) : qe(e2);
      }
      function Fe(e2) {
        null !== e2._byobRequest && (e2._byobRequest._associatedReadableByteStreamController = void 0, e2._byobRequest._view = null, e2._byobRequest = null);
      }
      function Ie(e2) {
        const t2 = [];
        for (; e2._pendingPullIntos.length > 0 && 0 !== e2._queueTotalSize; ) {
          const r2 = e2._pendingPullIntos.peek();
          ze(e2, r2) && (Ye(e2), t2.push(r2));
        }
        return t2;
      }
      function $e(e2, t2, r2, o2) {
        const n2 = e2._controlledReadableByteStream, a2 = t2.constructor, i2 = function(e3) {
          return Te(e3) ? 1 : e3.BYTES_PER_ELEMENT;
        }(a2), { byteOffset: l2, byteLength: s2 } = t2, u2 = r2 * i2;
        let c2;
        try {
          c2 = le(t2.buffer);
        } catch (e3) {
          return void o2._errorSteps(e3);
        }
        const d2 = { buffer: c2, bufferByteLength: c2.byteLength, byteOffset: l2, byteLength: s2, bytesFilled: 0, minimumFill: u2, elementSize: i2, viewConstructor: a2, readerType: "byob" };
        if (e2._pendingPullIntos.length > 0) return e2._pendingPullIntos.push(d2), void ot(n2, o2);
        if ("closed" !== n2._state) {
          if (e2._queueTotalSize > 0) {
            if (ze(e2, d2)) {
              const t3 = Oe(d2);
              return Le(e2), void o2._chunkSteps(t3);
            }
            if (e2._closeRequested) {
              const t3 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              return He(e2, t3), void o2._errorSteps(t3);
            }
          }
          e2._pendingPullIntos.push(d2), ot(n2, o2), qe(e2);
        } else {
          const e3 = new a2(d2.buffer, d2.byteOffset, 0);
          o2._closeSteps(e3);
        }
      }
      function Me(e2, t2) {
        const r2 = e2._pendingPullIntos.peek();
        Fe(e2);
        "closed" === e2._controlledReadableByteStream._state ? function(e3, t3) {
          "none" === t3.readerType && Ye(e3);
          const r3 = e3._controlledReadableByteStream;
          if (at(r3)) {
            const t4 = [];
            for (let o2 = 0; o2 < nt(r3); ++o2) t4.push(Ye(e3));
            Be(r3, t4);
          }
        }(e2, r2) : function(e3, t3, r3) {
          if (De(0, t3, r3), "none" === r3.readerType) {
            Ae(e3, r3);
            const t4 = Ie(e3);
            return void Be(e3._controlledReadableByteStream, t4);
          }
          if (r3.bytesFilled < r3.minimumFill) return;
          Ye(e3);
          const o2 = r3.bytesFilled % r3.elementSize;
          if (o2 > 0) {
            const t4 = r3.byteOffset + r3.bytesFilled;
            ke(e3, r3.buffer, t4 - o2, o2);
          }
          r3.bytesFilled -= o2;
          const n2 = Ie(e3);
          We(e3._controlledReadableByteStream, r3), Be(e3._controlledReadableByteStream, n2);
        }(e2, t2, r2), qe(e2);
      }
      function Ye(e2) {
        return e2._pendingPullIntos.shift();
      }
      function xe(e2) {
        e2._pullAlgorithm = void 0, e2._cancelAlgorithm = void 0;
      }
      function Qe(e2) {
        const t2 = e2._controlledReadableByteStream;
        if (!e2._closeRequested && "readable" === t2._state) if (e2._queueTotalSize > 0) e2._closeRequested = true;
        else {
          if (e2._pendingPullIntos.length > 0) {
            const t3 = e2._pendingPullIntos.peek();
            if (t3.bytesFilled % t3.elementSize != 0) {
              const t4 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              throw He(e2, t4), t4;
            }
          }
          xe(e2), jr(t2);
        }
      }
      function Ne(e2, t2) {
        const r2 = e2._controlledReadableByteStream;
        if (e2._closeRequested || "readable" !== r2._state) return;
        const { buffer: o2, byteOffset: n2, byteLength: a2 } = t2;
        if (se(o2)) throw new TypeError("chunk's buffer is detached and so cannot be enqueued");
        const i2 = le(o2);
        if (e2._pendingPullIntos.length > 0) {
          const t3 = e2._pendingPullIntos.peek();
          if (se(t3.buffer)) throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");
          Fe(e2), t3.buffer = le(t3.buffer), "none" === t3.readerType && Ae(e2, t3);
        }
        if (J(r2)) if (function(e3) {
          const t3 = e3._controlledReadableByteStream._reader;
          for (; t3._readRequests.length > 0; ) {
            if (0 === e3._queueTotalSize) return;
            Ve(e3, t3._readRequests.shift());
          }
        }(e2), 0 === X(r2)) je(e2, i2, n2, a2);
        else {
          e2._pendingPullIntos.length > 0 && Ye(e2);
          G(r2, new Uint8Array(i2, n2, a2), false);
        }
        else if (at(r2)) {
          je(e2, i2, n2, a2);
          const t3 = Ie(e2);
          Be(e2._controlledReadableByteStream, t3);
        } else je(e2, i2, n2, a2);
        qe(e2);
      }
      function He(e2, t2) {
        const r2 = e2._controlledReadableByteStream;
        "readable" === r2._state && (Ee(e2), Re(e2), xe(e2), kr(r2, t2));
      }
      function Ve(e2, t2) {
        const r2 = e2._queue.shift();
        e2._queueTotalSize -= r2.byteLength, Le(e2);
        const o2 = new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength);
        t2._chunkSteps(o2);
      }
      function Ue(e2) {
        if (null === e2._byobRequest && e2._pendingPullIntos.length > 0) {
          const t2 = e2._pendingPullIntos.peek(), r2 = new Uint8Array(t2.buffer, t2.byteOffset + t2.bytesFilled, t2.byteLength - t2.bytesFilled), o2 = Object.create(ReadableStreamBYOBRequest.prototype);
          !function(e3, t3, r3) {
            e3._associatedReadableByteStreamController = t3, e3._view = r3;
          }(o2, e2, r2), e2._byobRequest = o2;
        }
        return e2._byobRequest;
      }
      function Ge(e2) {
        const t2 = e2._controlledReadableByteStream._state;
        return "errored" === t2 ? null : "closed" === t2 ? 0 : e2._strategyHWM - e2._queueTotalSize;
      }
      function Xe(e2, t2) {
        const r2 = e2._pendingPullIntos.peek();
        if ("closed" === e2._controlledReadableByteStream._state) {
          if (0 !== t2) throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
        } else {
          if (0 === t2) throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
          if (r2.bytesFilled + t2 > r2.byteLength) throw new RangeError("bytesWritten out of range");
        }
        r2.buffer = le(r2.buffer), Me(e2, t2);
      }
      function Je(e2, t2) {
        const r2 = e2._pendingPullIntos.peek();
        if ("closed" === e2._controlledReadableByteStream._state) {
          if (0 !== t2.byteLength) throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
        } else if (0 === t2.byteLength) throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
        if (r2.byteOffset + r2.bytesFilled !== t2.byteOffset) throw new RangeError("The region specified by view does not match byobRequest");
        if (r2.bufferByteLength !== t2.buffer.byteLength) throw new RangeError("The buffer of view has different capacity than byobRequest");
        if (r2.bytesFilled + t2.byteLength > r2.byteLength) throw new RangeError("The region specified by view is larger than byobRequest");
        const o2 = t2.byteLength;
        r2.buffer = le(t2.buffer), Me(e2, o2);
      }
      function Ke(e2, t2, r2, o2, n2, a2, i2) {
        t2._controlledReadableByteStream = e2, t2._pullAgain = false, t2._pulling = false, t2._byobRequest = null, t2._queue = t2._queueTotalSize = void 0, Re(t2), t2._closeRequested = false, t2._started = false, t2._strategyHWM = a2, t2._pullAlgorithm = o2, t2._cancelAlgorithm = n2, t2._autoAllocateChunkSize = i2, t2._pendingPullIntos = new w(), e2._readableStreamController = t2;
        h(d(r2()), () => (t2._started = true, qe(t2), null), (e3) => (He(t2, e3), null));
      }
      function Ze(e2) {
        return new TypeError(`ReadableStreamBYOBRequest.prototype.${e2} can only be used on a ReadableStreamBYOBRequest`);
      }
      function et(e2) {
        return new TypeError(`ReadableByteStreamController.prototype.${e2} can only be used on a ReadableByteStreamController`);
      }
      function tt(e2, t2) {
        if ("byob" !== (e2 = `${e2}`)) throw new TypeError(`${t2} '${e2}' is not a valid enumeration value for ReadableStreamReaderMode`);
        return e2;
      }
      function rt(e2) {
        return new ReadableStreamBYOBReader(e2);
      }
      function ot(e2, t2) {
        e2._reader._readIntoRequests.push(t2);
      }
      function nt(e2) {
        return e2._reader._readIntoRequests.length;
      }
      function at(e2) {
        const t2 = e2._reader;
        return void 0 !== t2 && !!it(t2);
      }
      Object.defineProperties(ReadableByteStreamController.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, byobRequest: { enumerable: true }, desiredSize: { enumerable: true } }), n(ReadableByteStreamController.prototype.close, "close"), n(ReadableByteStreamController.prototype.enqueue, "enqueue"), n(ReadableByteStreamController.prototype.error, "error"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, { value: "ReadableByteStreamController", configurable: true });
      class ReadableStreamBYOBReader {
        constructor(e2) {
          if (M(e2, 1, "ReadableStreamBYOBReader"), H(e2, "First parameter"), Br(e2)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          if (!Ce(e2._readableStreamController)) throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
          E(this, e2), this._readIntoRequests = new w();
        }
        get closed() {
          return it(this) ? this._closedPromise : f(ut("closed"));
        }
        cancel(e2 = void 0) {
          return it(this) ? void 0 === this._ownerReadableStream ? f(O("cancel")) : W(this, e2) : f(ut("cancel"));
        }
        read(e2, t2 = {}) {
          if (!it(this)) return f(ut("read"));
          if (!ArrayBuffer.isView(e2)) return f(new TypeError("view must be an array buffer view"));
          if (0 === e2.byteLength) return f(new TypeError("view must have non-zero byteLength"));
          if (0 === e2.buffer.byteLength) return f(new TypeError("view's buffer must have non-zero byteLength"));
          if (se(e2.buffer)) return f(new TypeError("view's buffer has been detached"));
          let r2;
          try {
            r2 = function(e3, t3) {
              var r3;
              return F(e3, t3), { min: N(null !== (r3 = null == e3 ? void 0 : e3.min) && void 0 !== r3 ? r3 : 1, `${t3} has member 'min' that`) };
            }(t2, "options");
          } catch (e3) {
            return f(e3);
          }
          const o2 = r2.min;
          if (0 === o2) return f(new TypeError("options.min must be greater than 0"));
          if (function(e3) {
            return Te(e3.constructor);
          }(e2)) {
            if (o2 > e2.byteLength) return f(new RangeError("options.min must be less than or equal to view's byteLength"));
          } else if (o2 > e2.length) return f(new RangeError("options.min must be less than or equal to view's length"));
          if (void 0 === this._ownerReadableStream) return f(O("read from"));
          let n2, a2;
          const i2 = c((e3, t3) => {
            n2 = e3, a2 = t3;
          });
          return lt(this, e2, o2, { _chunkSteps: (e3) => n2({ value: e3, done: false }), _closeSteps: (e3) => n2({ value: e3, done: true }), _errorSteps: (e3) => a2(e3) }), i2;
        }
        releaseLock() {
          if (!it(this)) throw ut("releaseLock");
          void 0 !== this._ownerReadableStream && function(e2) {
            B(e2);
            const t2 = new TypeError("Reader was released");
            st(e2, t2);
          }(this);
        }
      }
      function it(e2) {
        return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_readIntoRequests") && e2 instanceof ReadableStreamBYOBReader);
      }
      function lt(e2, t2, r2, o2) {
        const n2 = e2._ownerReadableStream;
        n2._disturbed = true, "errored" === n2._state ? o2._errorSteps(n2._storedError) : $e(n2._readableStreamController, t2, r2, o2);
      }
      function st(e2, t2) {
        const r2 = e2._readIntoRequests;
        e2._readIntoRequests = new w(), r2.forEach((e3) => {
          e3._errorSteps(t2);
        });
      }
      function ut(e2) {
        return new TypeError(`ReadableStreamBYOBReader.prototype.${e2} can only be used on a ReadableStreamBYOBReader`);
      }
      function ct(e2, t2) {
        const { highWaterMark: r2 } = e2;
        if (void 0 === r2) return t2;
        if (Se(r2) || r2 < 0) throw new RangeError("Invalid highWaterMark");
        return r2;
      }
      function dt(e2) {
        const { size: t2 } = e2;
        return t2 || (() => 1);
      }
      function ft(e2, t2) {
        F(e2, t2);
        const r2 = null == e2 ? void 0 : e2.highWaterMark, o2 = null == e2 ? void 0 : e2.size;
        return { highWaterMark: void 0 === r2 ? void 0 : x(r2), size: void 0 === o2 ? void 0 : bt(o2, `${t2} has member 'size' that`) };
      }
      function bt(e2, t2) {
        return I(e2, t2), (t3) => x(e2(t3));
      }
      function ht(e2, t2, r2) {
        return I(e2, r2), (r3) => v(e2, t2, [r3]);
      }
      function mt(e2, t2, r2) {
        return I(e2, r2), () => v(e2, t2, []);
      }
      function _t(e2, t2, r2) {
        return I(e2, r2), (r3) => g(e2, t2, [r3]);
      }
      function pt(e2, t2, r2) {
        return I(e2, r2), (r3, o2) => v(e2, t2, [r3, o2]);
      }
      function yt(e2, t2) {
        if (!vt(e2)) throw new TypeError(`${t2} is not a WritableStream.`);
      }
      Object.defineProperties(ReadableStreamBYOBReader.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), n(ReadableStreamBYOBReader.prototype.cancel, "cancel"), n(ReadableStreamBYOBReader.prototype.read, "read"), n(ReadableStreamBYOBReader.prototype.releaseLock, "releaseLock"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, { value: "ReadableStreamBYOBReader", configurable: true });
      class WritableStream {
        constructor(e2 = {}, t2 = {}) {
          void 0 === e2 ? e2 = null : $(e2, "First parameter");
          const r2 = ft(t2, "Second parameter"), o2 = function(e3, t3) {
            F(e3, t3);
            const r3 = null == e3 ? void 0 : e3.abort, o3 = null == e3 ? void 0 : e3.close, n3 = null == e3 ? void 0 : e3.start, a2 = null == e3 ? void 0 : e3.type, i2 = null == e3 ? void 0 : e3.write;
            return { abort: void 0 === r3 ? void 0 : ht(r3, e3, `${t3} has member 'abort' that`), close: void 0 === o3 ? void 0 : mt(o3, e3, `${t3} has member 'close' that`), start: void 0 === n3 ? void 0 : _t(n3, e3, `${t3} has member 'start' that`), write: void 0 === i2 ? void 0 : pt(i2, e3, `${t3} has member 'write' that`), type: a2 };
          }(e2, "First parameter");
          gt(this);
          if (void 0 !== o2.type) throw new RangeError("Invalid type is specified");
          const n2 = dt(r2);
          !function(e3, t3, r3, o3) {
            const n3 = Object.create(WritableStreamDefaultController.prototype);
            let a2, i2, l2, s2;
            a2 = void 0 !== t3.start ? () => t3.start(n3) : () => {
            };
            i2 = void 0 !== t3.write ? (e4) => t3.write(e4, n3) : () => d(void 0);
            l2 = void 0 !== t3.close ? () => t3.close() : () => d(void 0);
            s2 = void 0 !== t3.abort ? (e4) => t3.abort(e4) : () => d(void 0);
            It(e3, n3, a2, i2, l2, s2, r3, o3);
          }(this, o2, ct(r2, 1), n2);
        }
        get locked() {
          if (!vt(this)) throw Ht("locked");
          return wt(this);
        }
        abort(e2 = void 0) {
          return vt(this) ? wt(this) ? f(new TypeError("Cannot abort a stream that already has a writer")) : Rt(this, e2) : f(Ht("abort"));
        }
        close() {
          return vt(this) ? wt(this) ? f(new TypeError("Cannot close a stream that already has a writer")) : Et(this) ? f(new TypeError("Cannot close an already-closing stream")) : Tt(this) : f(Ht("close"));
        }
        getWriter() {
          if (!vt(this)) throw Ht("getWriter");
          return St(this);
        }
      }
      function St(e2) {
        return new WritableStreamDefaultWriter(e2);
      }
      function gt(e2) {
        e2._state = "writable", e2._storedError = void 0, e2._writer = void 0, e2._writableStreamController = void 0, e2._writeRequests = new w(), e2._inFlightWriteRequest = void 0, e2._closeRequest = void 0, e2._inFlightCloseRequest = void 0, e2._pendingAbortRequest = void 0, e2._backpressure = false;
      }
      function vt(e2) {
        return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_writableStreamController") && e2 instanceof WritableStream);
      }
      function wt(e2) {
        return void 0 !== e2._writer;
      }
      function Rt(e2, t2) {
        var r2;
        if ("closed" === e2._state || "errored" === e2._state) return d(void 0);
        e2._writableStreamController._abortReason = t2, null === (r2 = e2._writableStreamController._abortController) || void 0 === r2 || r2.abort(t2);
        const o2 = e2._state;
        if ("closed" === o2 || "errored" === o2) return d(void 0);
        if (void 0 !== e2._pendingAbortRequest) return e2._pendingAbortRequest._promise;
        let n2 = false;
        "erroring" === o2 && (n2 = true, t2 = void 0);
        const a2 = c((r3, o3) => {
          e2._pendingAbortRequest = { _promise: void 0, _resolve: r3, _reject: o3, _reason: t2, _wasAlreadyErroring: n2 };
        });
        return e2._pendingAbortRequest._promise = a2, n2 || Pt(e2, t2), a2;
      }
      function Tt(e2) {
        const t2 = e2._state;
        if ("closed" === t2 || "errored" === t2) return f(new TypeError(`The stream (in ${t2} state) is not in the writable state and cannot be closed`));
        const r2 = c((t3, r3) => {
          const o3 = { _resolve: t3, _reject: r3 };
          e2._closeRequest = o3;
        }), o2 = e2._writer;
        var n2;
        return void 0 !== o2 && e2._backpressure && "writable" === t2 && nr(o2), we(n2 = e2._writableStreamController, Lt, 0), Yt(n2), r2;
      }
      function Ct(e2, t2) {
        "writable" !== e2._state ? qt(e2) : Pt(e2, t2);
      }
      function Pt(e2, t2) {
        const r2 = e2._writableStreamController;
        e2._state = "erroring", e2._storedError = t2;
        const o2 = e2._writer;
        void 0 !== o2 && At(o2, t2), !function(e3) {
          if (void 0 === e3._inFlightWriteRequest && void 0 === e3._inFlightCloseRequest) return false;
          return true;
        }(e2) && r2._started && qt(e2);
      }
      function qt(e2) {
        e2._state = "errored", e2._writableStreamController[T]();
        const t2 = e2._storedError;
        if (e2._writeRequests.forEach((e3) => {
          e3._reject(t2);
        }), e2._writeRequests = new w(), void 0 === e2._pendingAbortRequest) return void Wt(e2);
        const r2 = e2._pendingAbortRequest;
        if (e2._pendingAbortRequest = void 0, r2._wasAlreadyErroring) return r2._reject(t2), void Wt(e2);
        h(e2._writableStreamController[R](r2._reason), () => (r2._resolve(), Wt(e2), null), (t3) => (r2._reject(t3), Wt(e2), null));
      }
      function Et(e2) {
        return void 0 !== e2._closeRequest || void 0 !== e2._inFlightCloseRequest;
      }
      function Wt(e2) {
        void 0 !== e2._closeRequest && (e2._closeRequest._reject(e2._storedError), e2._closeRequest = void 0);
        const t2 = e2._writer;
        void 0 !== t2 && Kt(t2, e2._storedError);
      }
      function Bt(e2, t2) {
        const r2 = e2._writer;
        void 0 !== r2 && t2 !== e2._backpressure && (t2 ? function(e3) {
          er(e3);
        }(r2) : nr(r2)), e2._backpressure = t2;
      }
      Object.defineProperties(WritableStream.prototype, { abort: { enumerable: true }, close: { enumerable: true }, getWriter: { enumerable: true }, locked: { enumerable: true } }), n(WritableStream.prototype.abort, "abort"), n(WritableStream.prototype.close, "close"), n(WritableStream.prototype.getWriter, "getWriter"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, { value: "WritableStream", configurable: true });
      class WritableStreamDefaultWriter {
        constructor(e2) {
          if (M(e2, 1, "WritableStreamDefaultWriter"), yt(e2, "First parameter"), wt(e2)) throw new TypeError("This stream has already been locked for exclusive writing by another writer");
          this._ownerWritableStream = e2, e2._writer = this;
          const t2 = e2._state;
          if ("writable" === t2) !Et(e2) && e2._backpressure ? er(this) : rr(this), Xt(this);
          else if ("erroring" === t2) tr(this, e2._storedError), Xt(this);
          else if ("closed" === t2) rr(this), Xt(r2 = this), Zt(r2);
          else {
            const t3 = e2._storedError;
            tr(this, t3), Jt(this, t3);
          }
          var r2;
        }
        get closed() {
          return Ot(this) ? this._closedPromise : f(Ut("closed"));
        }
        get desiredSize() {
          if (!Ot(this)) throw Ut("desiredSize");
          if (void 0 === this._ownerWritableStream) throw Gt("desiredSize");
          return function(e2) {
            const t2 = e2._ownerWritableStream, r2 = t2._state;
            if ("errored" === r2 || "erroring" === r2) return null;
            if ("closed" === r2) return 0;
            return Mt(t2._writableStreamController);
          }(this);
        }
        get ready() {
          return Ot(this) ? this._readyPromise : f(Ut("ready"));
        }
        abort(e2 = void 0) {
          return Ot(this) ? void 0 === this._ownerWritableStream ? f(Gt("abort")) : function(e3, t2) {
            return Rt(e3._ownerWritableStream, t2);
          }(this, e2) : f(Ut("abort"));
        }
        close() {
          if (!Ot(this)) return f(Ut("close"));
          const e2 = this._ownerWritableStream;
          return void 0 === e2 ? f(Gt("close")) : Et(e2) ? f(new TypeError("Cannot close an already-closing stream")) : jt(this);
        }
        releaseLock() {
          if (!Ot(this)) throw Ut("releaseLock");
          void 0 !== this._ownerWritableStream && zt(this);
        }
        write(e2 = void 0) {
          return Ot(this) ? void 0 === this._ownerWritableStream ? f(Gt("write to")) : Dt(this, e2) : f(Ut("write"));
        }
      }
      function Ot(e2) {
        return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_ownerWritableStream") && e2 instanceof WritableStreamDefaultWriter);
      }
      function jt(e2) {
        return Tt(e2._ownerWritableStream);
      }
      function kt(e2, t2) {
        "pending" === e2._closedPromiseState ? Kt(e2, t2) : function(e3, t3) {
          Jt(e3, t3);
        }(e2, t2);
      }
      function At(e2, t2) {
        "pending" === e2._readyPromiseState ? or(e2, t2) : function(e3, t3) {
          tr(e3, t3);
        }(e2, t2);
      }
      function zt(e2) {
        const t2 = e2._ownerWritableStream, r2 = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
        At(e2, r2), kt(e2, r2), t2._writer = void 0, e2._ownerWritableStream = void 0;
      }
      function Dt(e2, t2) {
        const r2 = e2._ownerWritableStream, o2 = r2._writableStreamController, n2 = function(e3, t3) {
          if (void 0 === e3._strategySizeAlgorithm) return 1;
          try {
            return e3._strategySizeAlgorithm(t3);
          } catch (t4) {
            return xt(e3, t4), 1;
          }
        }(o2, t2);
        if (r2 !== e2._ownerWritableStream) return f(Gt("write to"));
        const a2 = r2._state;
        if ("errored" === a2) return f(r2._storedError);
        if (Et(r2) || "closed" === a2) return f(new TypeError("The stream is closing or closed and cannot be written to"));
        if ("erroring" === a2) return f(r2._storedError);
        const i2 = function(e3) {
          return c((t3, r3) => {
            const o3 = { _resolve: t3, _reject: r3 };
            e3._writeRequests.push(o3);
          });
        }(r2);
        return function(e3, t3, r3) {
          try {
            we(e3, t3, r3);
          } catch (t4) {
            return void xt(e3, t4);
          }
          const o3 = e3._controlledWritableStream;
          if (!Et(o3) && "writable" === o3._state) {
            Bt(o3, Qt(e3));
          }
          Yt(e3);
        }(o2, t2, n2), i2;
      }
      Object.defineProperties(WritableStreamDefaultWriter.prototype, { abort: { enumerable: true }, close: { enumerable: true }, releaseLock: { enumerable: true }, write: { enumerable: true }, closed: { enumerable: true }, desiredSize: { enumerable: true }, ready: { enumerable: true } }), n(WritableStreamDefaultWriter.prototype.abort, "abort"), n(WritableStreamDefaultWriter.prototype.close, "close"), n(WritableStreamDefaultWriter.prototype.releaseLock, "releaseLock"), n(WritableStreamDefaultWriter.prototype.write, "write"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, { value: "WritableStreamDefaultWriter", configurable: true });
      const Lt = {};
      class WritableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get abortReason() {
          if (!Ft(this)) throw Vt("abortReason");
          return this._abortReason;
        }
        get signal() {
          if (!Ft(this)) throw Vt("signal");
          if (void 0 === this._abortController) throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
          return this._abortController.signal;
        }
        error(e2 = void 0) {
          if (!Ft(this)) throw Vt("error");
          "writable" === this._controlledWritableStream._state && Nt(this, e2);
        }
        [R](e2) {
          const t2 = this._abortAlgorithm(e2);
          return $t(this), t2;
        }
        [T]() {
          Re(this);
        }
      }
      function Ft(e2) {
        return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_controlledWritableStream") && e2 instanceof WritableStreamDefaultController);
      }
      function It(e2, t2, r2, o2, n2, a2, i2, l2) {
        t2._controlledWritableStream = e2, e2._writableStreamController = t2, t2._queue = void 0, t2._queueTotalSize = void 0, Re(t2), t2._abortReason = void 0, t2._abortController = function() {
          if ("function" == typeof AbortController) return new AbortController();
        }(), t2._started = false, t2._strategySizeAlgorithm = l2, t2._strategyHWM = i2, t2._writeAlgorithm = o2, t2._closeAlgorithm = n2, t2._abortAlgorithm = a2;
        const s2 = Qt(t2);
        Bt(e2, s2);
        h(d(r2()), () => (t2._started = true, Yt(t2), null), (r3) => (t2._started = true, Ct(e2, r3), null));
      }
      function $t(e2) {
        e2._writeAlgorithm = void 0, e2._closeAlgorithm = void 0, e2._abortAlgorithm = void 0, e2._strategySizeAlgorithm = void 0;
      }
      function Mt(e2) {
        return e2._strategyHWM - e2._queueTotalSize;
      }
      function Yt(e2) {
        const t2 = e2._controlledWritableStream;
        if (!e2._started) return;
        if (void 0 !== t2._inFlightWriteRequest) return;
        if ("erroring" === t2._state) return void qt(t2);
        if (0 === e2._queue.length) return;
        const r2 = e2._queue.peek().value;
        r2 === Lt ? function(e3) {
          const t3 = e3._controlledWritableStream;
          (function(e4) {
            e4._inFlightCloseRequest = e4._closeRequest, e4._closeRequest = void 0;
          })(t3), ve(e3);
          const r3 = e3._closeAlgorithm();
          $t(e3), h(r3, () => (function(e4) {
            e4._inFlightCloseRequest._resolve(void 0), e4._inFlightCloseRequest = void 0, "erroring" === e4._state && (e4._storedError = void 0, void 0 !== e4._pendingAbortRequest && (e4._pendingAbortRequest._resolve(), e4._pendingAbortRequest = void 0)), e4._state = "closed";
            const t4 = e4._writer;
            void 0 !== t4 && Zt(t4);
          }(t3), null), (e4) => (function(e5, t4) {
            e5._inFlightCloseRequest._reject(t4), e5._inFlightCloseRequest = void 0, void 0 !== e5._pendingAbortRequest && (e5._pendingAbortRequest._reject(t4), e5._pendingAbortRequest = void 0), Ct(e5, t4);
          }(t3, e4), null));
        }(e2) : function(e3, t3) {
          const r3 = e3._controlledWritableStream;
          !function(e4) {
            e4._inFlightWriteRequest = e4._writeRequests.shift();
          }(r3);
          const o2 = e3._writeAlgorithm(t3);
          h(o2, () => {
            !function(e4) {
              e4._inFlightWriteRequest._resolve(void 0), e4._inFlightWriteRequest = void 0;
            }(r3);
            const t4 = r3._state;
            if (ve(e3), !Et(r3) && "writable" === t4) {
              const t5 = Qt(e3);
              Bt(r3, t5);
            }
            return Yt(e3), null;
          }, (t4) => ("writable" === r3._state && $t(e3), function(e4, t5) {
            e4._inFlightWriteRequest._reject(t5), e4._inFlightWriteRequest = void 0, Ct(e4, t5);
          }(r3, t4), null));
        }(e2, r2);
      }
      function xt(e2, t2) {
        "writable" === e2._controlledWritableStream._state && Nt(e2, t2);
      }
      function Qt(e2) {
        return Mt(e2) <= 0;
      }
      function Nt(e2, t2) {
        const r2 = e2._controlledWritableStream;
        $t(e2), Pt(r2, t2);
      }
      function Ht(e2) {
        return new TypeError(`WritableStream.prototype.${e2} can only be used on a WritableStream`);
      }
      function Vt(e2) {
        return new TypeError(`WritableStreamDefaultController.prototype.${e2} can only be used on a WritableStreamDefaultController`);
      }
      function Ut(e2) {
        return new TypeError(`WritableStreamDefaultWriter.prototype.${e2} can only be used on a WritableStreamDefaultWriter`);
      }
      function Gt(e2) {
        return new TypeError("Cannot " + e2 + " a stream using a released writer");
      }
      function Xt(e2) {
        e2._closedPromise = c((t2, r2) => {
          e2._closedPromise_resolve = t2, e2._closedPromise_reject = r2, e2._closedPromiseState = "pending";
        });
      }
      function Jt(e2, t2) {
        Xt(e2), Kt(e2, t2);
      }
      function Kt(e2, t2) {
        void 0 !== e2._closedPromise_reject && (y(e2._closedPromise), e2._closedPromise_reject(t2), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0, e2._closedPromiseState = "rejected");
      }
      function Zt(e2) {
        void 0 !== e2._closedPromise_resolve && (e2._closedPromise_resolve(void 0), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0, e2._closedPromiseState = "resolved");
      }
      function er(e2) {
        e2._readyPromise = c((t2, r2) => {
          e2._readyPromise_resolve = t2, e2._readyPromise_reject = r2;
        }), e2._readyPromiseState = "pending";
      }
      function tr(e2, t2) {
        er(e2), or(e2, t2);
      }
      function rr(e2) {
        er(e2), nr(e2);
      }
      function or(e2, t2) {
        void 0 !== e2._readyPromise_reject && (y(e2._readyPromise), e2._readyPromise_reject(t2), e2._readyPromise_resolve = void 0, e2._readyPromise_reject = void 0, e2._readyPromiseState = "rejected");
      }
      function nr(e2) {
        void 0 !== e2._readyPromise_resolve && (e2._readyPromise_resolve(void 0), e2._readyPromise_resolve = void 0, e2._readyPromise_reject = void 0, e2._readyPromiseState = "fulfilled");
      }
      Object.defineProperties(WritableStreamDefaultController.prototype, { abortReason: { enumerable: true }, signal: { enumerable: true }, error: { enumerable: true } }), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, { value: "WritableStreamDefaultController", configurable: true });
      const ar = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof global ? global : void 0;
      const ir = function() {
        const e2 = null == ar ? void 0 : ar.DOMException;
        return function(e3) {
          if ("function" != typeof e3 && "object" != typeof e3) return false;
          if ("DOMException" !== e3.name) return false;
          try {
            return new e3(), true;
          } catch (e4) {
            return false;
          }
        }(e2) ? e2 : void 0;
      }() || function() {
        const e2 = function(e3, t2) {
          this.message = e3 || "", this.name = t2 || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
        };
        return n(e2, "DOMException"), e2.prototype = Object.create(Error.prototype), Object.defineProperty(e2.prototype, "constructor", { value: e2, writable: true, configurable: true }), e2;
      }();
      function lr(e2, r2, o2, n2, a2, i2) {
        const l2 = V(e2), s2 = St(r2);
        e2._disturbed = true;
        let u2 = false, p2 = d(void 0);
        return c((S2, g2) => {
          let v2;
          if (void 0 !== i2) {
            if (v2 = () => {
              const t2 = void 0 !== i2.reason ? i2.reason : new ir("Aborted", "AbortError"), o3 = [];
              n2 || o3.push(() => "writable" === r2._state ? Rt(r2, t2) : d(void 0)), a2 || o3.push(() => "readable" === e2._state ? Or(e2, t2) : d(void 0)), q2(() => Promise.all(o3.map((e3) => e3())), true, t2);
            }, i2.aborted) return void v2();
            i2.addEventListener("abort", v2);
          }
          var w2, R2, T2;
          if (P2(e2, l2._closedPromise, (e3) => (n2 ? E2(true, e3) : q2(() => Rt(r2, e3), true, e3), null)), P2(r2, s2._closedPromise, (t2) => (a2 ? E2(true, t2) : q2(() => Or(e2, t2), true, t2), null)), w2 = e2, R2 = l2._closedPromise, T2 = () => (o2 ? E2() : q2(() => function(e3) {
            const t2 = e3._ownerWritableStream, r3 = t2._state;
            return Et(t2) || "closed" === r3 ? d(void 0) : "errored" === r3 ? f(t2._storedError) : jt(e3);
          }(s2)), null), "closed" === w2._state ? T2() : m(R2, T2), Et(r2) || "closed" === r2._state) {
            const t2 = new TypeError("the destination writable stream closed before all data could be piped to it");
            a2 ? E2(true, t2) : q2(() => Or(e2, t2), true, t2);
          }
          function C2() {
            const e3 = p2;
            return b(p2, () => e3 !== p2 ? C2() : void 0);
          }
          function P2(e3, t2, r3) {
            "errored" === e3._state ? r3(e3._storedError) : _(t2, r3);
          }
          function q2(e3, t2, o3) {
            function n3() {
              return h(e3(), () => W2(t2, o3), (e4) => W2(true, e4)), null;
            }
            u2 || (u2 = true, "writable" !== r2._state || Et(r2) ? n3() : m(C2(), n3));
          }
          function E2(e3, t2) {
            u2 || (u2 = true, "writable" !== r2._state || Et(r2) ? W2(e3, t2) : m(C2(), () => W2(e3, t2)));
          }
          function W2(e3, t2) {
            return zt(s2), B(l2), void 0 !== i2 && i2.removeEventListener("abort", v2), e3 ? g2(t2) : S2(void 0), null;
          }
          y(c((e3, r3) => {
            !function o3(n3) {
              n3 ? e3() : b(u2 ? d(true) : b(s2._readyPromise, () => c((e4, r4) => {
                Z(l2, { _chunkSteps: (r5) => {
                  p2 = b(Dt(s2, r5), void 0, t), e4(false);
                }, _closeSteps: () => e4(true), _errorSteps: r4 });
              })), o3, r3);
            }(false);
          }));
        });
      }
      class ReadableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get desiredSize() {
          if (!sr(this)) throw yr("desiredSize");
          return mr(this);
        }
        close() {
          if (!sr(this)) throw yr("close");
          if (!_r(this)) throw new TypeError("The stream is not in a state that permits close");
          fr(this);
        }
        enqueue(e2 = void 0) {
          if (!sr(this)) throw yr("enqueue");
          if (!_r(this)) throw new TypeError("The stream is not in a state that permits enqueue");
          return br(this, e2);
        }
        error(e2 = void 0) {
          if (!sr(this)) throw yr("error");
          hr(this, e2);
        }
        [C](e2) {
          Re(this);
          const t2 = this._cancelAlgorithm(e2);
          return dr(this), t2;
        }
        [P](e2) {
          const t2 = this._controlledReadableStream;
          if (this._queue.length > 0) {
            const r2 = ve(this);
            this._closeRequested && 0 === this._queue.length ? (dr(this), jr(t2)) : ur(this), e2._chunkSteps(r2);
          } else U(t2, e2), ur(this);
        }
        [q]() {
        }
      }
      function sr(e2) {
        return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_controlledReadableStream") && e2 instanceof ReadableStreamDefaultController);
      }
      function ur(e2) {
        if (!cr(e2)) return;
        if (e2._pulling) return void (e2._pullAgain = true);
        e2._pulling = true;
        h(e2._pullAlgorithm(), () => (e2._pulling = false, e2._pullAgain && (e2._pullAgain = false, ur(e2)), null), (t2) => (hr(e2, t2), null));
      }
      function cr(e2) {
        const t2 = e2._controlledReadableStream;
        if (!_r(e2)) return false;
        if (!e2._started) return false;
        if (Br(t2) && X(t2) > 0) return true;
        return mr(e2) > 0;
      }
      function dr(e2) {
        e2._pullAlgorithm = void 0, e2._cancelAlgorithm = void 0, e2._strategySizeAlgorithm = void 0;
      }
      function fr(e2) {
        if (!_r(e2)) return;
        const t2 = e2._controlledReadableStream;
        e2._closeRequested = true, 0 === e2._queue.length && (dr(e2), jr(t2));
      }
      function br(e2, t2) {
        if (!_r(e2)) return;
        const r2 = e2._controlledReadableStream;
        if (Br(r2) && X(r2) > 0) G(r2, t2, false);
        else {
          let r3;
          try {
            r3 = e2._strategySizeAlgorithm(t2);
          } catch (t3) {
            throw hr(e2, t3), t3;
          }
          try {
            we(e2, t2, r3);
          } catch (t3) {
            throw hr(e2, t3), t3;
          }
        }
        ur(e2);
      }
      function hr(e2, t2) {
        const r2 = e2._controlledReadableStream;
        "readable" === r2._state && (Re(e2), dr(e2), kr(r2, t2));
      }
      function mr(e2) {
        const t2 = e2._controlledReadableStream._state;
        return "errored" === t2 ? null : "closed" === t2 ? 0 : e2._strategyHWM - e2._queueTotalSize;
      }
      function _r(e2) {
        const t2 = e2._controlledReadableStream._state;
        return !e2._closeRequested && "readable" === t2;
      }
      function pr(e2, t2, r2, o2, n2, a2, i2) {
        t2._controlledReadableStream = e2, t2._queue = void 0, t2._queueTotalSize = void 0, Re(t2), t2._started = false, t2._closeRequested = false, t2._pullAgain = false, t2._pulling = false, t2._strategySizeAlgorithm = i2, t2._strategyHWM = a2, t2._pullAlgorithm = o2, t2._cancelAlgorithm = n2, e2._readableStreamController = t2;
        h(d(r2()), () => (t2._started = true, ur(t2), null), (e3) => (hr(t2, e3), null));
      }
      function yr(e2) {
        return new TypeError(`ReadableStreamDefaultController.prototype.${e2} can only be used on a ReadableStreamDefaultController`);
      }
      function Sr(e2, t2) {
        return Ce(e2._readableStreamController) ? function(e3) {
          let t3, r2, o2, n2, a2, i2 = V(e3), l2 = false, s2 = false, u2 = false, f2 = false, b2 = false;
          const h2 = c((e4) => {
            a2 = e4;
          });
          function m2(e4) {
            _(e4._closedPromise, (t4) => (e4 !== i2 || (He(o2._readableStreamController, t4), He(n2._readableStreamController, t4), f2 && b2 || a2(void 0)), null));
          }
          function p2() {
            it(i2) && (B(i2), i2 = V(e3), m2(i2));
            Z(i2, { _chunkSteps: (t4) => {
              S(() => {
                s2 = false, u2 = false;
                const r3 = t4;
                let i3 = t4;
                if (!f2 && !b2) try {
                  i3 = ge(t4);
                } catch (t5) {
                  return He(o2._readableStreamController, t5), He(n2._readableStreamController, t5), void a2(Or(e3, t5));
                }
                f2 || Ne(o2._readableStreamController, r3), b2 || Ne(n2._readableStreamController, i3), l2 = false, s2 ? g2() : u2 && v2();
              });
            }, _closeSteps: () => {
              l2 = false, f2 || Qe(o2._readableStreamController), b2 || Qe(n2._readableStreamController), o2._readableStreamController._pendingPullIntos.length > 0 && Xe(o2._readableStreamController, 0), n2._readableStreamController._pendingPullIntos.length > 0 && Xe(n2._readableStreamController, 0), f2 && b2 || a2(void 0);
            }, _errorSteps: () => {
              l2 = false;
            } });
          }
          function y2(t4, r3) {
            K(i2) && (B(i2), i2 = rt(e3), m2(i2));
            const c2 = r3 ? n2 : o2, d2 = r3 ? o2 : n2;
            lt(i2, t4, 1, { _chunkSteps: (t5) => {
              S(() => {
                s2 = false, u2 = false;
                const o3 = r3 ? b2 : f2;
                if (r3 ? f2 : b2) o3 || Je(c2._readableStreamController, t5);
                else {
                  let r4;
                  try {
                    r4 = ge(t5);
                  } catch (t6) {
                    return He(c2._readableStreamController, t6), He(d2._readableStreamController, t6), void a2(Or(e3, t6));
                  }
                  o3 || Je(c2._readableStreamController, t5), Ne(d2._readableStreamController, r4);
                }
                l2 = false, s2 ? g2() : u2 && v2();
              });
            }, _closeSteps: (e4) => {
              l2 = false;
              const t5 = r3 ? b2 : f2, o3 = r3 ? f2 : b2;
              t5 || Qe(c2._readableStreamController), o3 || Qe(d2._readableStreamController), void 0 !== e4 && (t5 || Je(c2._readableStreamController, e4), !o3 && d2._readableStreamController._pendingPullIntos.length > 0 && Xe(d2._readableStreamController, 0)), t5 && o3 || a2(void 0);
            }, _errorSteps: () => {
              l2 = false;
            } });
          }
          function g2() {
            if (l2) return s2 = true, d(void 0);
            l2 = true;
            const e4 = Ue(o2._readableStreamController);
            return null === e4 ? p2() : y2(e4._view, false), d(void 0);
          }
          function v2() {
            if (l2) return u2 = true, d(void 0);
            l2 = true;
            const e4 = Ue(n2._readableStreamController);
            return null === e4 ? p2() : y2(e4._view, true), d(void 0);
          }
          function w2(o3) {
            if (f2 = true, t3 = o3, b2) {
              const o4 = ae([t3, r2]), n3 = Or(e3, o4);
              a2(n3);
            }
            return h2;
          }
          function R2(o3) {
            if (b2 = true, r2 = o3, f2) {
              const o4 = ae([t3, r2]), n3 = Or(e3, o4);
              a2(n3);
            }
            return h2;
          }
          function T2() {
          }
          return o2 = qr(T2, g2, w2), n2 = qr(T2, v2, R2), m2(i2), [o2, n2];
        }(e2) : function(e3, t3) {
          const r2 = V(e3);
          let o2, n2, a2, i2, l2, s2 = false, u2 = false, f2 = false, b2 = false;
          const h2 = c((e4) => {
            l2 = e4;
          });
          function m2() {
            if (s2) return u2 = true, d(void 0);
            s2 = true;
            return Z(r2, { _chunkSteps: (e4) => {
              S(() => {
                u2 = false;
                const t4 = e4, r3 = e4;
                f2 || br(a2._readableStreamController, t4), b2 || br(i2._readableStreamController, r3), s2 = false, u2 && m2();
              });
            }, _closeSteps: () => {
              s2 = false, f2 || fr(a2._readableStreamController), b2 || fr(i2._readableStreamController), f2 && b2 || l2(void 0);
            }, _errorSteps: () => {
              s2 = false;
            } }), d(void 0);
          }
          function p2(t4) {
            if (f2 = true, o2 = t4, b2) {
              const t5 = ae([o2, n2]), r3 = Or(e3, t5);
              l2(r3);
            }
            return h2;
          }
          function y2(t4) {
            if (b2 = true, n2 = t4, f2) {
              const t5 = ae([o2, n2]), r3 = Or(e3, t5);
              l2(r3);
            }
            return h2;
          }
          function g2() {
          }
          return a2 = Pr(g2, m2, p2), i2 = Pr(g2, m2, y2), _(r2._closedPromise, (e4) => (hr(a2._readableStreamController, e4), hr(i2._readableStreamController, e4), f2 && b2 || l2(void 0), null)), [a2, i2];
        }(e2);
      }
      function gr(e2) {
        return r(o2 = e2) && void 0 !== o2.getReader ? function(e3) {
          let o3;
          function n2() {
            let t2;
            try {
              t2 = e3.read();
            } catch (e4) {
              return f(e4);
            }
            return p(t2, (e4) => {
              if (!r(e4)) throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");
              if (e4.done) fr(o3._readableStreamController);
              else {
                const t3 = e4.value;
                br(o3._readableStreamController, t3);
              }
            });
          }
          function a2(t2) {
            try {
              return d(e3.cancel(t2));
            } catch (e4) {
              return f(e4);
            }
          }
          return o3 = Pr(t, n2, a2, 0), o3;
        }(e2.getReader()) : function(e3) {
          let o3;
          const n2 = be(e3, "async");
          function a2() {
            let e4;
            try {
              e4 = he(n2);
            } catch (e5) {
              return f(e5);
            }
            return p(d(e4), (e5) => {
              if (!r(e5)) throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");
              if (e5.done) fr(o3._readableStreamController);
              else {
                const t2 = e5.value;
                br(o3._readableStreamController, t2);
              }
            });
          }
          function i2(e4) {
            const t2 = n2.iterator;
            let o4;
            try {
              o4 = ce(t2, "return");
            } catch (e5) {
              return f(e5);
            }
            if (void 0 === o4) return d(void 0);
            return p(v(o4, t2, [e4]), (e5) => {
              if (!r(e5)) throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");
            });
          }
          return o3 = Pr(t, a2, i2, 0), o3;
        }(e2);
        var o2;
      }
      function vr(e2, t2, r2) {
        return I(e2, r2), (r3) => v(e2, t2, [r3]);
      }
      function wr(e2, t2, r2) {
        return I(e2, r2), (r3) => v(e2, t2, [r3]);
      }
      function Rr(e2, t2, r2) {
        return I(e2, r2), (r3) => g(e2, t2, [r3]);
      }
      function Tr(e2, t2) {
        if ("bytes" !== (e2 = `${e2}`)) throw new TypeError(`${t2} '${e2}' is not a valid enumeration value for ReadableStreamType`);
        return e2;
      }
      function Cr(e2, t2) {
        F(e2, t2);
        const r2 = null == e2 ? void 0 : e2.preventAbort, o2 = null == e2 ? void 0 : e2.preventCancel, n2 = null == e2 ? void 0 : e2.preventClose, a2 = null == e2 ? void 0 : e2.signal;
        return void 0 !== a2 && function(e3, t3) {
          if (!function(e4) {
            if ("object" != typeof e4 || null === e4) return false;
            try {
              return "boolean" == typeof e4.aborted;
            } catch (e5) {
              return false;
            }
          }(e3)) throw new TypeError(`${t3} is not an AbortSignal.`);
        }(a2, `${t2} has member 'signal' that`), { preventAbort: Boolean(r2), preventCancel: Boolean(o2), preventClose: Boolean(n2), signal: a2 };
      }
      Object.defineProperties(ReadableStreamDefaultController.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, desiredSize: { enumerable: true } }), n(ReadableStreamDefaultController.prototype.close, "close"), n(ReadableStreamDefaultController.prototype.enqueue, "enqueue"), n(ReadableStreamDefaultController.prototype.error, "error"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, { value: "ReadableStreamDefaultController", configurable: true });
      class ReadableStream {
        constructor(e2 = {}, t2 = {}) {
          void 0 === e2 ? e2 = null : $(e2, "First parameter");
          const r2 = ft(t2, "Second parameter"), o2 = function(e3, t3) {
            F(e3, t3);
            const r3 = e3, o3 = null == r3 ? void 0 : r3.autoAllocateChunkSize, n2 = null == r3 ? void 0 : r3.cancel, a2 = null == r3 ? void 0 : r3.pull, i2 = null == r3 ? void 0 : r3.start, l2 = null == r3 ? void 0 : r3.type;
            return { autoAllocateChunkSize: void 0 === o3 ? void 0 : N(o3, `${t3} has member 'autoAllocateChunkSize' that`), cancel: void 0 === n2 ? void 0 : vr(n2, r3, `${t3} has member 'cancel' that`), pull: void 0 === a2 ? void 0 : wr(a2, r3, `${t3} has member 'pull' that`), start: void 0 === i2 ? void 0 : Rr(i2, r3, `${t3} has member 'start' that`), type: void 0 === l2 ? void 0 : Tr(l2, `${t3} has member 'type' that`) };
          }(e2, "First parameter");
          if (Er(this), "bytes" === o2.type) {
            if (void 0 !== r2.size) throw new RangeError("The strategy for a byte stream cannot have a size function");
            !function(e3, t3, r3) {
              const o3 = Object.create(ReadableByteStreamController.prototype);
              let n2, a2, i2;
              n2 = void 0 !== t3.start ? () => t3.start(o3) : () => {
              }, a2 = void 0 !== t3.pull ? () => t3.pull(o3) : () => d(void 0), i2 = void 0 !== t3.cancel ? (e4) => t3.cancel(e4) : () => d(void 0);
              const l2 = t3.autoAllocateChunkSize;
              if (0 === l2) throw new TypeError("autoAllocateChunkSize must be greater than 0");
              Ke(e3, o3, n2, a2, i2, r3, l2);
            }(this, o2, ct(r2, 0));
          } else {
            const e3 = dt(r2);
            !function(e4, t3, r3, o3) {
              const n2 = Object.create(ReadableStreamDefaultController.prototype);
              let a2, i2, l2;
              a2 = void 0 !== t3.start ? () => t3.start(n2) : () => {
              }, i2 = void 0 !== t3.pull ? () => t3.pull(n2) : () => d(void 0), l2 = void 0 !== t3.cancel ? (e5) => t3.cancel(e5) : () => d(void 0), pr(e4, n2, a2, i2, l2, r3, o3);
            }(this, o2, ct(r2, 1), e3);
          }
        }
        get locked() {
          if (!Wr(this)) throw Ar("locked");
          return Br(this);
        }
        cancel(e2 = void 0) {
          return Wr(this) ? Br(this) ? f(new TypeError("Cannot cancel a stream that already has a reader")) : Or(this, e2) : f(Ar("cancel"));
        }
        getReader(e2 = void 0) {
          if (!Wr(this)) throw Ar("getReader");
          return void 0 === function(e3, t2) {
            F(e3, t2);
            const r2 = null == e3 ? void 0 : e3.mode;
            return { mode: void 0 === r2 ? void 0 : tt(r2, `${t2} has member 'mode' that`) };
          }(e2, "First parameter").mode ? V(this) : rt(this);
        }
        pipeThrough(e2, t2 = {}) {
          if (!Wr(this)) throw Ar("pipeThrough");
          M(e2, 1, "pipeThrough");
          const r2 = function(e3, t3) {
            F(e3, t3);
            const r3 = null == e3 ? void 0 : e3.readable;
            Y(r3, "readable", "ReadableWritablePair"), H(r3, `${t3} has member 'readable' that`);
            const o3 = null == e3 ? void 0 : e3.writable;
            return Y(o3, "writable", "ReadableWritablePair"), yt(o3, `${t3} has member 'writable' that`), { readable: r3, writable: o3 };
          }(e2, "First parameter"), o2 = Cr(t2, "Second parameter");
          if (Br(this)) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
          if (wt(r2.writable)) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
          return y(lr(this, r2.writable, o2.preventClose, o2.preventAbort, o2.preventCancel, o2.signal)), r2.readable;
        }
        pipeTo(e2, t2 = {}) {
          if (!Wr(this)) return f(Ar("pipeTo"));
          if (void 0 === e2) return f("Parameter 1 is required in 'pipeTo'.");
          if (!vt(e2)) return f(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
          let r2;
          try {
            r2 = Cr(t2, "Second parameter");
          } catch (e3) {
            return f(e3);
          }
          return Br(this) ? f(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : wt(e2) ? f(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : lr(this, e2, r2.preventClose, r2.preventAbort, r2.preventCancel, r2.signal);
        }
        tee() {
          if (!Wr(this)) throw Ar("tee");
          return ae(Sr(this));
        }
        values(e2 = void 0) {
          if (!Wr(this)) throw Ar("values");
          return function(e3, t2) {
            const r2 = V(e3), o2 = new me(r2, t2), n2 = Object.create(_e);
            return n2._asyncIteratorImpl = o2, n2;
          }(this, function(e3, t2) {
            F(e3, t2);
            const r2 = null == e3 ? void 0 : e3.preventCancel;
            return { preventCancel: Boolean(r2) };
          }(e2, "First parameter").preventCancel);
        }
        [fe](e2) {
          return this.values(e2);
        }
        static from(e2) {
          return gr(e2);
        }
      }
      function Pr(e2, t2, r2, o2 = 1, n2 = () => 1) {
        const a2 = Object.create(ReadableStream.prototype);
        Er(a2);
        return pr(a2, Object.create(ReadableStreamDefaultController.prototype), e2, t2, r2, o2, n2), a2;
      }
      function qr(e2, t2, r2) {
        const o2 = Object.create(ReadableStream.prototype);
        Er(o2);
        return Ke(o2, Object.create(ReadableByteStreamController.prototype), e2, t2, r2, 0, void 0), o2;
      }
      function Er(e2) {
        e2._state = "readable", e2._reader = void 0, e2._storedError = void 0, e2._disturbed = false;
      }
      function Wr(e2) {
        return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_readableStreamController") && e2 instanceof ReadableStream);
      }
      function Br(e2) {
        return void 0 !== e2._reader;
      }
      function Or(e2, r2) {
        if (e2._disturbed = true, "closed" === e2._state) return d(void 0);
        if ("errored" === e2._state) return f(e2._storedError);
        jr(e2);
        const o2 = e2._reader;
        if (void 0 !== o2 && it(o2)) {
          const e3 = o2._readIntoRequests;
          o2._readIntoRequests = new w(), e3.forEach((e4) => {
            e4._closeSteps(void 0);
          });
        }
        return p(e2._readableStreamController[C](r2), t);
      }
      function jr(e2) {
        e2._state = "closed";
        const t2 = e2._reader;
        if (void 0 !== t2 && (z(t2), K(t2))) {
          const e3 = t2._readRequests;
          t2._readRequests = new w(), e3.forEach((e4) => {
            e4._closeSteps();
          });
        }
      }
      function kr(e2, t2) {
        e2._state = "errored", e2._storedError = t2;
        const r2 = e2._reader;
        void 0 !== r2 && (A(r2, t2), K(r2) ? ee(r2, t2) : st(r2, t2));
      }
      function Ar(e2) {
        return new TypeError(`ReadableStream.prototype.${e2} can only be used on a ReadableStream`);
      }
      function zr(e2, t2) {
        F(e2, t2);
        const r2 = null == e2 ? void 0 : e2.highWaterMark;
        return Y(r2, "highWaterMark", "QueuingStrategyInit"), { highWaterMark: x(r2) };
      }
      Object.defineProperties(ReadableStream, { from: { enumerable: true } }), Object.defineProperties(ReadableStream.prototype, { cancel: { enumerable: true }, getReader: { enumerable: true }, pipeThrough: { enumerable: true }, pipeTo: { enumerable: true }, tee: { enumerable: true }, values: { enumerable: true }, locked: { enumerable: true } }), n(ReadableStream.from, "from"), n(ReadableStream.prototype.cancel, "cancel"), n(ReadableStream.prototype.getReader, "getReader"), n(ReadableStream.prototype.pipeThrough, "pipeThrough"), n(ReadableStream.prototype.pipeTo, "pipeTo"), n(ReadableStream.prototype.tee, "tee"), n(ReadableStream.prototype.values, "values"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStream.prototype, Symbol.toStringTag, { value: "ReadableStream", configurable: true }), Object.defineProperty(ReadableStream.prototype, fe, { value: ReadableStream.prototype.values, writable: true, configurable: true });
      const Dr = (e2) => e2.byteLength;
      n(Dr, "size");
      class ByteLengthQueuingStrategy {
        constructor(e2) {
          M(e2, 1, "ByteLengthQueuingStrategy"), e2 = zr(e2, "First parameter"), this._byteLengthQueuingStrategyHighWaterMark = e2.highWaterMark;
        }
        get highWaterMark() {
          if (!Fr(this)) throw Lr("highWaterMark");
          return this._byteLengthQueuingStrategyHighWaterMark;
        }
        get size() {
          if (!Fr(this)) throw Lr("size");
          return Dr;
        }
      }
      function Lr(e2) {
        return new TypeError(`ByteLengthQueuingStrategy.prototype.${e2} can only be used on a ByteLengthQueuingStrategy`);
      }
      function Fr(e2) {
        return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_byteLengthQueuingStrategyHighWaterMark") && e2 instanceof ByteLengthQueuingStrategy);
      }
      Object.defineProperties(ByteLengthQueuingStrategy.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, { value: "ByteLengthQueuingStrategy", configurable: true });
      const Ir = () => 1;
      n(Ir, "size");
      class CountQueuingStrategy {
        constructor(e2) {
          M(e2, 1, "CountQueuingStrategy"), e2 = zr(e2, "First parameter"), this._countQueuingStrategyHighWaterMark = e2.highWaterMark;
        }
        get highWaterMark() {
          if (!Mr(this)) throw $r("highWaterMark");
          return this._countQueuingStrategyHighWaterMark;
        }
        get size() {
          if (!Mr(this)) throw $r("size");
          return Ir;
        }
      }
      function $r(e2) {
        return new TypeError(`CountQueuingStrategy.prototype.${e2} can only be used on a CountQueuingStrategy`);
      }
      function Mr(e2) {
        return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_countQueuingStrategyHighWaterMark") && e2 instanceof CountQueuingStrategy);
      }
      function Yr(e2, t2, r2) {
        return I(e2, r2), (r3) => v(e2, t2, [r3]);
      }
      function xr(e2, t2, r2) {
        return I(e2, r2), (r3) => g(e2, t2, [r3]);
      }
      function Qr(e2, t2, r2) {
        return I(e2, r2), (r3, o2) => v(e2, t2, [r3, o2]);
      }
      function Nr(e2, t2, r2) {
        return I(e2, r2), (r3) => v(e2, t2, [r3]);
      }
      Object.defineProperties(CountQueuingStrategy.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, { value: "CountQueuingStrategy", configurable: true });
      class TransformStream {
        constructor(e2 = {}, t2 = {}, r2 = {}) {
          void 0 === e2 && (e2 = null);
          const o2 = ft(t2, "Second parameter"), n2 = ft(r2, "Third parameter"), a2 = function(e3, t3) {
            F(e3, t3);
            const r3 = null == e3 ? void 0 : e3.cancel, o3 = null == e3 ? void 0 : e3.flush, n3 = null == e3 ? void 0 : e3.readableType, a3 = null == e3 ? void 0 : e3.start, i3 = null == e3 ? void 0 : e3.transform, l3 = null == e3 ? void 0 : e3.writableType;
            return { cancel: void 0 === r3 ? void 0 : Nr(r3, e3, `${t3} has member 'cancel' that`), flush: void 0 === o3 ? void 0 : Yr(o3, e3, `${t3} has member 'flush' that`), readableType: n3, start: void 0 === a3 ? void 0 : xr(a3, e3, `${t3} has member 'start' that`), transform: void 0 === i3 ? void 0 : Qr(i3, e3, `${t3} has member 'transform' that`), writableType: l3 };
          }(e2, "First parameter");
          if (void 0 !== a2.readableType) throw new RangeError("Invalid readableType specified");
          if (void 0 !== a2.writableType) throw new RangeError("Invalid writableType specified");
          const i2 = ct(n2, 0), l2 = dt(n2), s2 = ct(o2, 1), u2 = dt(o2);
          let b2;
          !function(e3, t3, r3, o3, n3, a3) {
            function i3() {
              return t3;
            }
            function l3(t4) {
              return function(e4, t5) {
                const r4 = e4._transformStreamController;
                if (e4._backpressure) {
                  return p(e4._backpressureChangePromise, () => {
                    const o4 = e4._writable;
                    if ("erroring" === o4._state) throw o4._storedError;
                    return eo(r4, t5);
                  });
                }
                return eo(r4, t5);
              }(e3, t4);
            }
            function s3(t4) {
              return function(e4, t5) {
                const r4 = e4._transformStreamController;
                if (void 0 !== r4._finishPromise) return r4._finishPromise;
                const o4 = e4._readable;
                r4._finishPromise = c((e5, t6) => {
                  r4._finishPromise_resolve = e5, r4._finishPromise_reject = t6;
                });
                const n4 = r4._cancelAlgorithm(t5);
                return Kr(r4), h(n4, () => ("errored" === o4._state ? oo(r4, o4._storedError) : (hr(o4._readableStreamController, t5), ro(r4)), null), (e5) => (hr(o4._readableStreamController, e5), oo(r4, e5), null)), r4._finishPromise;
              }(e3, t4);
            }
            function u3() {
              return function(e4) {
                const t4 = e4._transformStreamController;
                if (void 0 !== t4._finishPromise) return t4._finishPromise;
                const r4 = e4._readable;
                t4._finishPromise = c((e5, r5) => {
                  t4._finishPromise_resolve = e5, t4._finishPromise_reject = r5;
                });
                const o4 = t4._flushAlgorithm();
                return Kr(t4), h(o4, () => ("errored" === r4._state ? oo(t4, r4._storedError) : (fr(r4._readableStreamController), ro(t4)), null), (e5) => (hr(r4._readableStreamController, e5), oo(t4, e5), null)), t4._finishPromise;
              }(e3);
            }
            function d2() {
              return function(e4) {
                return Xr(e4, false), e4._backpressureChangePromise;
              }(e3);
            }
            function f2(t4) {
              return function(e4, t5) {
                const r4 = e4._transformStreamController;
                if (void 0 !== r4._finishPromise) return r4._finishPromise;
                const o4 = e4._writable;
                r4._finishPromise = c((e5, t6) => {
                  r4._finishPromise_resolve = e5, r4._finishPromise_reject = t6;
                });
                const n4 = r4._cancelAlgorithm(t5);
                return Kr(r4), h(n4, () => ("errored" === o4._state ? oo(r4, o4._storedError) : (xt(o4._writableStreamController, t5), Gr(e4), ro(r4)), null), (t6) => (xt(o4._writableStreamController, t6), Gr(e4), oo(r4, t6), null)), r4._finishPromise;
              }(e3, t4);
            }
            e3._writable = function(e4, t4, r4, o4, n4 = 1, a4 = () => 1) {
              const i4 = Object.create(WritableStream.prototype);
              return gt(i4), It(i4, Object.create(WritableStreamDefaultController.prototype), e4, t4, r4, o4, n4, a4), i4;
            }(i3, l3, u3, s3, r3, o3), e3._readable = Pr(i3, d2, f2, n3, a3), e3._backpressure = void 0, e3._backpressureChangePromise = void 0, e3._backpressureChangePromise_resolve = void 0, Xr(e3, true), e3._transformStreamController = void 0;
          }(this, c((e3) => {
            b2 = e3;
          }), s2, u2, i2, l2), function(e3, t3) {
            const r3 = Object.create(TransformStreamDefaultController.prototype);
            let o3, n3, a3;
            o3 = void 0 !== t3.transform ? (e4) => t3.transform(e4, r3) : (e4) => {
              try {
                return Zr(r3, e4), d(void 0);
              } catch (e5) {
                return f(e5);
              }
            };
            n3 = void 0 !== t3.flush ? () => t3.flush(r3) : () => d(void 0);
            a3 = void 0 !== t3.cancel ? (e4) => t3.cancel(e4) : () => d(void 0);
            !function(e4, t4, r4, o4, n4) {
              t4._controlledTransformStream = e4, e4._transformStreamController = t4, t4._transformAlgorithm = r4, t4._flushAlgorithm = o4, t4._cancelAlgorithm = n4, t4._finishPromise = void 0, t4._finishPromise_resolve = void 0, t4._finishPromise_reject = void 0;
            }(e3, r3, o3, n3, a3);
          }(this, a2), void 0 !== a2.start ? b2(a2.start(this._transformStreamController)) : b2(void 0);
        }
        get readable() {
          if (!Hr(this)) throw no("readable");
          return this._readable;
        }
        get writable() {
          if (!Hr(this)) throw no("writable");
          return this._writable;
        }
      }
      function Hr(e2) {
        return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_transformStreamController") && e2 instanceof TransformStream);
      }
      function Vr(e2, t2) {
        hr(e2._readable._readableStreamController, t2), Ur(e2, t2);
      }
      function Ur(e2, t2) {
        Kr(e2._transformStreamController), xt(e2._writable._writableStreamController, t2), Gr(e2);
      }
      function Gr(e2) {
        e2._backpressure && Xr(e2, false);
      }
      function Xr(e2, t2) {
        void 0 !== e2._backpressureChangePromise && e2._backpressureChangePromise_resolve(), e2._backpressureChangePromise = c((t3) => {
          e2._backpressureChangePromise_resolve = t3;
        }), e2._backpressure = t2;
      }
      Object.defineProperties(TransformStream.prototype, { readable: { enumerable: true }, writable: { enumerable: true } }), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, { value: "TransformStream", configurable: true });
      class TransformStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get desiredSize() {
          if (!Jr(this)) throw to("desiredSize");
          return mr(this._controlledTransformStream._readable._readableStreamController);
        }
        enqueue(e2 = void 0) {
          if (!Jr(this)) throw to("enqueue");
          Zr(this, e2);
        }
        error(e2 = void 0) {
          if (!Jr(this)) throw to("error");
          var t2;
          t2 = e2, Vr(this._controlledTransformStream, t2);
        }
        terminate() {
          if (!Jr(this)) throw to("terminate");
          !function(e2) {
            const t2 = e2._controlledTransformStream;
            fr(t2._readable._readableStreamController);
            const r2 = new TypeError("TransformStream terminated");
            Ur(t2, r2);
          }(this);
        }
      }
      function Jr(e2) {
        return !!r(e2) && (!!Object.prototype.hasOwnProperty.call(e2, "_controlledTransformStream") && e2 instanceof TransformStreamDefaultController);
      }
      function Kr(e2) {
        e2._transformAlgorithm = void 0, e2._flushAlgorithm = void 0, e2._cancelAlgorithm = void 0;
      }
      function Zr(e2, t2) {
        const r2 = e2._controlledTransformStream, o2 = r2._readable._readableStreamController;
        if (!_r(o2)) throw new TypeError("Readable side is not in a state that permits enqueue");
        try {
          br(o2, t2);
        } catch (e3) {
          throw Ur(r2, e3), r2._readable._storedError;
        }
        const n2 = function(e3) {
          return !cr(e3);
        }(o2);
        n2 !== r2._backpressure && Xr(r2, true);
      }
      function eo(e2, t2) {
        return p(e2._transformAlgorithm(t2), void 0, (t3) => {
          throw Vr(e2._controlledTransformStream, t3), t3;
        });
      }
      function to(e2) {
        return new TypeError(`TransformStreamDefaultController.prototype.${e2} can only be used on a TransformStreamDefaultController`);
      }
      function ro(e2) {
        void 0 !== e2._finishPromise_resolve && (e2._finishPromise_resolve(), e2._finishPromise_resolve = void 0, e2._finishPromise_reject = void 0);
      }
      function oo(e2, t2) {
        void 0 !== e2._finishPromise_reject && (y(e2._finishPromise), e2._finishPromise_reject(t2), e2._finishPromise_resolve = void 0, e2._finishPromise_reject = void 0);
      }
      function no(e2) {
        return new TypeError(`TransformStream.prototype.${e2} can only be used on a TransformStream`);
      }
      Object.defineProperties(TransformStreamDefaultController.prototype, { enqueue: { enumerable: true }, error: { enumerable: true }, terminate: { enumerable: true }, desiredSize: { enumerable: true } }), n(TransformStreamDefaultController.prototype.enqueue, "enqueue"), n(TransformStreamDefaultController.prototype.error, "error"), n(TransformStreamDefaultController.prototype.terminate, "terminate"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, { value: "TransformStreamDefaultController", configurable: true }), e.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy, e.CountQueuingStrategy = CountQueuingStrategy, e.ReadableByteStreamController = ReadableByteStreamController, e.ReadableStream = ReadableStream, e.ReadableStreamBYOBReader = ReadableStreamBYOBReader, e.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest, e.ReadableStreamDefaultController = ReadableStreamDefaultController, e.ReadableStreamDefaultReader = ReadableStreamDefaultReader, e.TransformStream = TransformStream, e.TransformStreamDefaultController = TransformStreamDefaultController, e.WritableStream = WritableStream, e.WritableStreamDefaultController = WritableStreamDefaultController, e.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
    });
  }
});
export default require_ponyfill();
/*! Bundled license information:

web-streams-polyfill/dist/ponyfill.js:
  (**
   * @license
   * web-streams-polyfill v4.1.0
   * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
   * This code is released under the MIT license.
   * SPDX-License-Identifier: MIT
   *)
*/
//# sourceMappingURL=web-streams-polyfill_dist_ponyfill__js.js.map
