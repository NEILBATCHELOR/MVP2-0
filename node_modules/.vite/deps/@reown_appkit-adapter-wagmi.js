import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  ChainNotConfiguredError,
  ProviderNotFoundError,
  connect,
  createConfig,
  createConnector,
  disconnect,
  estimateGas,
  getAccount,
  getBalance,
  getConnections,
  injected,
  prepareTransactionRequest,
  reconnect,
  sendTransaction,
  signMessage,
  switchChain,
  waitForTransactionReceipt,
  watchAccount,
  watchConnectors,
  watchPendingTransactions,
  writeContract
} from "./chunk-CBG2ZFP5.js";
import {
  W3mFrameProviderSingleton
} from "./chunk-SXTNS6EH.js";
import {
  AdapterBlueprint,
  WalletConnectConnector,
  WcHelpersUtil
} from "./chunk-HO7F4MGR.js";
import "./chunk-BKGHPC6Y.js";
import "./chunk-AOLNHFMV.js";
import "./chunk-UYZJ7K2H.js";
import "./chunk-5LF73QIQ.js";
import {
  CaipNetworksUtil,
  ErrorUtil,
  PresetsUtil
} from "./chunk-F5BLFGNY.js";
import {
  AccountController,
  AlertController,
  ChainController,
  ConstantsUtil,
  CoreHelperUtil,
  NetworkUtil,
  OptionsController,
  StorageUtil,
  proxy,
  subscribeKey
} from "./chunk-C5LFNDH4.js";
import "./chunk-J6MFVBAG.js";
import "./chunk-HEAK4C5H.js";
import "./chunk-M7ESHJZM.js";
import "./chunk-DUBGYLDB.js";
import "./chunk-5AEVLWJ7.js";
import {
  parseUnits
} from "./chunk-NVFBXQQ3.js";
import "./chunk-J3BDJH22.js";
import "./chunk-YC2WMYH7.js";
import "./chunk-GLG5WABG.js";
import "./chunk-KQZXP73G.js";
import "./chunk-H56ALCTR.js";
import "./chunk-MJERGRIX.js";
import "./chunk-X6ZZOJ46.js";
import "./chunk-ZG7SPMF4.js";
import {
  SwitchChainError,
  UserRejectedRequestError
} from "./chunk-6BTRFLJF.js";
import "./chunk-JDHQP5DF.js";
import "./chunk-LOB4ZIE3.js";
import "./chunk-ORQLP7ZA.js";
import {
  formatUnits,
  getAddress,
  numberToHex
} from "./chunk-CFULN7WL.js";
import "./chunk-N34Q7N5W.js";
import "./chunk-7GYUITQP.js";
import "./chunk-DIA6PCXS.js";
import "./chunk-MZSKM7EO.js";
import "./chunk-CAUVRPQ2.js";
import "./chunk-ROAYBCNV.js";
import {
  __toESM,
  init_globalPolyfills,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-F62UFKTJ.js";

// node_modules/.pnpm/@reown+appkit-adapter-wagmi@1.7.8_@types+react@18.3.23_@wagmi+core@2.17.3_@tanstack+que_6d7829fc3866ba4c2f279130cedcf539/node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/index.js
init_globalPolyfills();
var import_dist40 = __toESM(require_dist());
var import_dist41 = __toESM(require_dist2());
var import_dist42 = __toESM(require_dist3());

// node_modules/.pnpm/@reown+appkit-adapter-wagmi@1.7.8_@types+react@18.3.23_@wagmi+core@2.17.3_@tanstack+que_6d7829fc3866ba4c2f279130cedcf539/node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/client.js
init_globalPolyfills();
var import_dist37 = __toESM(require_dist(), 1);
var import_dist38 = __toESM(require_dist2(), 1);
var import_dist39 = __toESM(require_dist3(), 1);

// node_modules/.pnpm/@wagmi+core@2.17.3_@tanstack+query-core@5.80.6_@types+react@18.3.23_react@18.3.1_typesc_3b361b471aa7f244a365c666cbe40be8/node_modules/@wagmi/core/dist/esm/exports/chains.js
init_globalPolyfills();
var import_dist = __toESM(require_dist());
var import_dist2 = __toESM(require_dist2());
var import_dist3 = __toESM(require_dist3());

// node_modules/.pnpm/@reown+appkit@1.7.8_@types+react@18.3.23_bufferutil@4.0.9_react@18.3.1_typescript@5.8.3_5cc87f27141f63e121be55d99aa28f0e/node_modules/@reown/appkit/dist/esm/exports/index.js
init_globalPolyfills();
var import_dist4 = __toESM(require_dist());
var import_dist5 = __toESM(require_dist2());
var import_dist6 = __toESM(require_dist3());

// node_modules/.pnpm/@reown+appkit@1.7.8_@types+react@18.3.23_bufferutil@4.0.9_react@18.3.1_typescript@5.8.3_5cc87f27141f63e121be55d99aa28f0e/node_modules/@reown/appkit/dist/esm/exports/adapters.js
init_globalPolyfills();
var import_dist10 = __toESM(require_dist());
var import_dist11 = __toESM(require_dist2());
var import_dist12 = __toESM(require_dist3());

// node_modules/.pnpm/@reown+appkit@1.7.8_@types+react@18.3.23_bufferutil@4.0.9_react@18.3.1_typescript@5.8.3_5cc87f27141f63e121be55d99aa28f0e/node_modules/@reown/appkit/dist/esm/src/adapters/index.js
init_globalPolyfills();
var import_dist7 = __toESM(require_dist(), 1);
var import_dist8 = __toESM(require_dist2(), 1);
var import_dist9 = __toESM(require_dist3(), 1);

// node_modules/.pnpm/@reown+appkit@1.7.8_@types+react@18.3.23_bufferutil@4.0.9_react@18.3.1_typescript@5.8.3_5cc87f27141f63e121be55d99aa28f0e/node_modules/@reown/appkit/dist/esm/exports/connectors.js
init_globalPolyfills();
var import_dist16 = __toESM(require_dist());
var import_dist17 = __toESM(require_dist2());
var import_dist18 = __toESM(require_dist3());

// node_modules/.pnpm/@reown+appkit@1.7.8_@types+react@18.3.23_bufferutil@4.0.9_react@18.3.1_typescript@5.8.3_5cc87f27141f63e121be55d99aa28f0e/node_modules/@reown/appkit/dist/esm/src/connectors/index.js
init_globalPolyfills();
var import_dist13 = __toESM(require_dist(), 1);
var import_dist14 = __toESM(require_dist2(), 1);
var import_dist15 = __toESM(require_dist3(), 1);

// node_modules/.pnpm/@reown+appkit-adapter-wagmi@1.7.8_@types+react@18.3.23_@wagmi+core@2.17.3_@tanstack+que_6d7829fc3866ba4c2f279130cedcf539/node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/connectors/AuthConnector.js
init_globalPolyfills();
var import_dist25 = __toESM(require_dist(), 1);
var import_dist26 = __toESM(require_dist2(), 1);
var import_dist27 = __toESM(require_dist3(), 1);

// node_modules/.pnpm/@reown+appkit@1.7.8_@types+react@18.3.23_bufferutil@4.0.9_react@18.3.1_typescript@5.8.3_5cc87f27141f63e121be55d99aa28f0e/node_modules/@reown/appkit/dist/esm/exports/auth-provider.js
init_globalPolyfills();
var import_dist22 = __toESM(require_dist());
var import_dist23 = __toESM(require_dist2());
var import_dist24 = __toESM(require_dist3());

// node_modules/.pnpm/@reown+appkit@1.7.8_@types+react@18.3.23_bufferutil@4.0.9_react@18.3.1_typescript@5.8.3_5cc87f27141f63e121be55d99aa28f0e/node_modules/@reown/appkit/dist/esm/src/auth-provider/index.js
init_globalPolyfills();
var import_dist19 = __toESM(require_dist(), 1);
var import_dist20 = __toESM(require_dist2(), 1);
var import_dist21 = __toESM(require_dist3(), 1);

// node_modules/.pnpm/@reown+appkit-adapter-wagmi@1.7.8_@types+react@18.3.23_@wagmi+core@2.17.3_@tanstack+que_6d7829fc3866ba4c2f279130cedcf539/node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/connectors/AuthConnector.js
function authConnector(parameters) {
  let currentAccounts = [];
  let socialProvider = void 0;
  let connectSocialPromise = void 0;
  function parseChainId(chainId) {
    return NetworkUtil.parseEvmChainId(chainId) || 1;
  }
  function getProviderInstance() {
    if (!socialProvider) {
      socialProvider = W3mFrameProviderSingleton.getInstance({
        projectId: parameters.options.projectId,
        chainId: ChainController.getActiveCaipNetwork()?.caipNetworkId,
        enableLogger: parameters.options.enableAuthLogger,
        onTimeout: (reason) => {
          if (reason === "iframe_load_failed") {
            AlertController.open(ErrorUtil.ALERT_ERRORS.IFRAME_LOAD_FAILED, "error");
          } else if (reason === "iframe_request_timeout") {
            AlertController.open(ErrorUtil.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT, "error");
          } else if (reason === "unverified_domain") {
            AlertController.open(ErrorUtil.ALERT_ERRORS.UNVERIFIED_DOMAIN, "error");
          }
        },
        abortController: ErrorUtil.EmbeddedWalletAbortController
      });
    }
    return socialProvider;
  }
  async function connectSocial(options = {}) {
    const provider = getProviderInstance();
    let chainId = options.chainId;
    if (options.isReconnecting) {
      const lastUsedChainId = NetworkUtil.parseEvmChainId(provider.getLastUsedChainId() || "");
      const defaultChainId = parameters.chains?.[0].id;
      chainId = lastUsedChainId || defaultChainId;
      if (!chainId) {
        throw new Error("ChainId not found in provider");
      }
    }
    const preferredAccountType = AccountController.state.preferredAccountTypes?.eip155;
    const { address, chainId: frameChainId, accounts } = await provider.connect({
      chainId,
      preferredAccountType,
      socialUri: options.socialUri
    });
    currentAccounts = accounts?.map((a) => a.address) || [address];
    const parsedChainId = parseChainId(frameChainId);
    return {
      accounts: currentAccounts,
      account: address,
      chainId: parsedChainId,
      chain: {
        id: parsedChainId,
        unsuported: false
      }
    };
  }
  return createConnector((config) => ({
    id: ConstantsUtil.CONNECTOR_ID.AUTH,
    name: ConstantsUtil.CONNECTOR_NAMES.AUTH,
    type: "AUTH",
    chain: ConstantsUtil.CHAIN.EVM,
    async connect(options = {}) {
      if (connectSocialPromise) {
        return connectSocialPromise;
      }
      if (!connectSocialPromise) {
        connectSocialPromise = new Promise((resolve) => {
          resolve(connectSocial(options));
        });
      }
      const result = await connectSocialPromise;
      connectSocialPromise = void 0;
      return result;
    },
    async disconnect() {
      const provider = await this.getProvider();
      await provider.disconnect();
    },
    getAccounts() {
      if (!currentAccounts?.length) {
        return Promise.resolve([]);
      }
      config.emitter.emit("change", { accounts: currentAccounts });
      return Promise.resolve(currentAccounts);
    },
    async getProvider() {
      if (!this.provider) {
        this.provider = W3mFrameProviderSingleton.getInstance({
          projectId: parameters.options.projectId,
          chainId: ChainController.getActiveCaipNetwork()?.caipNetworkId,
          enableLogger: parameters.options.enableAuthLogger,
          abortController: ErrorUtil.EmbeddedWalletAbortController,
          onTimeout: (reason) => {
            if (reason === "iframe_load_failed") {
              AlertController.open(ErrorUtil.ALERT_ERRORS.IFRAME_LOAD_FAILED, "error");
            } else if (reason === "iframe_request_timeout") {
              AlertController.open(ErrorUtil.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT, "error");
            } else if (reason === "unverified_domain") {
              AlertController.open(ErrorUtil.ALERT_ERRORS.UNVERIFIED_DOMAIN, "error");
            }
          }
        });
      }
      return Promise.resolve(this.provider);
    },
    async getChainId() {
      const provider = await this.getProvider();
      const { chainId } = await provider.getChainId();
      return parseChainId(chainId);
    },
    async isAuthorized() {
      const provider = await this.getProvider();
      return Promise.resolve(provider.getLoginEmailUsed());
    },
    async switchChain({ chainId }) {
      try {
        const chain = config.chains.find((c) => c.id === chainId);
        if (!chain) {
          throw new SwitchChainError(new Error("chain not found on connector."));
        }
        const provider = await this.getProvider();
        const preferredAccountType = AccountController.state.preferredAccountTypes?.eip155;
        const response = await provider.connect({
          chainId,
          preferredAccountType
        });
        currentAccounts = response?.accounts?.map((a) => a.address) || [
          response.address
        ];
        config.emitter.emit("change", {
          chainId: Number(chainId),
          accounts: currentAccounts
        });
        return chain;
      } catch (error) {
        if (error instanceof Error) {
          throw new SwitchChainError(error);
        }
        throw error;
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0) {
        this.onDisconnect();
      } else {
        config.emitter.emit("change", { accounts: accounts.map(getAddress) });
      }
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    async onDisconnect(_error) {
      const provider = await this.getProvider();
      await provider.disconnect();
    }
  }));
}

// node_modules/.pnpm/@reown+appkit-adapter-wagmi@1.7.8_@types+react@18.3.23_@wagmi+core@2.17.3_@tanstack+que_6d7829fc3866ba4c2f279130cedcf539/node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/connectors/UniversalConnector.js
init_globalPolyfills();
var import_dist28 = __toESM(require_dist(), 1);
var import_dist29 = __toESM(require_dist2(), 1);
var import_dist30 = __toESM(require_dist3(), 1);
walletConnect.type = "walletConnect";
function walletConnect(parameters, appKit) {
  const isNewChainsStale = parameters.isNewChainsStale ?? true;
  let provider_;
  let accountsChanged;
  let chainChanged;
  let connect2;
  let displayUri;
  let sessionDelete;
  let disconnect2;
  return createConnector((config) => ({
    id: "walletConnect",
    name: "WalletConnect",
    type: walletConnect.type,
    async setup() {
      const provider = await this.getProvider().catch(() => null);
      if (!provider) {
        return;
      }
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider.on("connect", connect2);
      }
      if (!sessionDelete) {
        sessionDelete = this.onSessionDelete.bind(this);
        provider.on("session_delete", sessionDelete);
      }
    },
    async connect({ ...rest } = {}) {
      try {
        const caipNetworks = ChainController.getCaipNetworks();
        const provider = await this.getProvider();
        if (!provider) {
          throw new ProviderNotFoundError();
        }
        if (!displayUri) {
          displayUri = this.onDisplayUri;
          provider.on("display_uri", displayUri);
        }
        const isChainsStale = await this.isChainsStale();
        if (provider.session && isChainsStale) {
          await provider.disconnect();
        }
        const universalProviderConfigOverride = OptionsController.state.universalProviderConfigOverride;
        if (!provider.session || isChainsStale) {
          const namespaces = WcHelpersUtil.createNamespaces(caipNetworks, universalProviderConfigOverride);
          await provider.connect({
            optionalNamespaces: namespaces,
            ..."pairingTopic" in rest ? { pairingTopic: rest.pairingTopic } : {}
          });
          this.setRequestedChainsIds(caipNetworks.map((x) => Number(x.id)));
        }
        const accounts = await this.getAccounts();
        const requestChainId = await this.getChainId();
        const chains = provider.session?.namespaces?.["eip155"]?.chains;
        const isRequestedChainSupported = chains?.some((chain) => Number(chain.split(":")[1]) === requestChainId);
        let currentChainId = 1;
        if (isRequestedChainSupported) {
          currentChainId = requestChainId;
        } else if (chains?.[0]) {
          currentChainId = Number(chains[0].split(":")[1]);
        }
        if (displayUri) {
          provider.removeListener("display_uri", displayUri);
          displayUri = void 0;
        }
        if (connect2) {
          provider.removeListener("connect", connect2);
          connect2 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect2);
        }
        if (!sessionDelete) {
          sessionDelete = this.onSessionDelete.bind(this);
          provider.on("session_delete", sessionDelete);
        }
        const defaultChain = universalProviderConfigOverride?.defaultChain;
        provider.setDefaultChain(defaultChain ?? `eip155:${currentChainId}`);
        return { accounts, chainId: currentChainId };
      } catch (error) {
        if (/(user rejected|connection request reset)/i.test(error?.message)) {
          throw new UserRejectedRequestError(error);
        }
        throw error;
      }
    },
    async disconnect() {
      const provider = await this.getProvider();
      try {
        await provider?.disconnect();
      } catch (error) {
        if (!/No matching key/i.test(error.message)) {
          throw error;
        }
      } finally {
        if (chainChanged) {
          provider?.removeListener("chainChanged", chainChanged);
          chainChanged = void 0;
        }
        if (disconnect2) {
          provider?.removeListener("disconnect", disconnect2);
          disconnect2 = void 0;
        }
        if (!connect2) {
          connect2 = this.onConnect.bind(this);
          provider?.on("connect", connect2);
        }
        if (accountsChanged) {
          provider?.removeListener("accountsChanged", accountsChanged);
          accountsChanged = void 0;
        }
        if (sessionDelete) {
          provider?.removeListener("session_delete", sessionDelete);
          sessionDelete = void 0;
        }
        this.setRequestedChainsIds([]);
      }
    },
    async getAccounts() {
      const provider = await this.getProvider();
      if (!provider?.session?.namespaces) {
        return [];
      }
      const accountsList = provider?.session?.namespaces[ConstantsUtil.CHAIN.EVM]?.accounts;
      const accounts = accountsList?.map((account) => account.split(":")[2]) ?? [];
      return accounts;
    },
    async getProvider({ chainId } = {}) {
      if (!provider_) {
        provider_ = await appKit.getUniversalProvider();
        provider_?.events.setMaxListeners(Number.POSITIVE_INFINITY);
      }
      const activeNamespace = StorageUtil.getActiveNamespace();
      const currentChainId = appKit.getCaipNetwork()?.id;
      if (chainId && currentChainId !== chainId && activeNamespace) {
        const storedCaipNetworkId = StorageUtil.getStoredActiveCaipNetworkId();
        const appKitCaipNetworks = appKit.getCaipNetworks(activeNamespace);
        const storedCaipNetwork = appKitCaipNetworks?.find((n) => n.id === storedCaipNetworkId);
        if (storedCaipNetwork && storedCaipNetwork.chainNamespace === ConstantsUtil.CHAIN.EVM) {
          await this.switchChain?.({ chainId: Number(storedCaipNetwork.id) });
        }
      }
      return provider_;
    },
    async getChainId() {
      const chainId = appKit.getCaipNetwork(ConstantsUtil.CHAIN.EVM)?.id;
      if (chainId) {
        return chainId;
      }
      const provider = await this.getProvider();
      const chain = provider.session?.namespaces[ConstantsUtil.CHAIN.EVM]?.chains?.[0];
      const network = ChainController.getCaipNetworks().find((c) => c.id === chain);
      return network?.id;
    },
    async isAuthorized() {
      try {
        const [accounts, provider] = await Promise.all([this.getAccounts(), this.getProvider()]);
        if (!accounts.length) {
          return false;
        }
        const isChainsStale = await this.isChainsStale();
        if (isChainsStale && provider.session) {
          await provider.disconnect().catch(() => {
          });
          return false;
        }
        return true;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      const provider = await this.getProvider();
      if (!provider) {
        throw new ProviderNotFoundError();
      }
      const chainToSwitch = ChainController.getCaipNetworks().find((x) => x.id === chainId);
      if (!chainToSwitch) {
        throw new SwitchChainError(new ChainNotConfiguredError());
      }
      try {
        await provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chainId) }]
        });
        if (chainToSwitch?.caipNetworkId) {
          provider.setDefaultChain(chainToSwitch?.caipNetworkId);
        }
        config.emitter.emit("change", { chainId: Number(chainId) });
        const requestedChains = await this.getRequestedChainsIds();
        this.setRequestedChainsIds([...requestedChains, chainId]);
        return { ...chainToSwitch, id: chainToSwitch.id };
      } catch (err) {
        const error = err;
        if (/(?:user rejected)/iu.test(error.message)) {
          throw new UserRejectedRequestError(error);
        }
        try {
          let blockExplorerUrls;
          if (addEthereumChainParameter?.blockExplorerUrls) {
            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
          } else {
            blockExplorerUrls = chainToSwitch.blockExplorers?.default.url ? [chainToSwitch.blockExplorers?.default.url] : [];
          }
          const rpcUrls = chainToSwitch.rpcUrls?.["chainDefault"]?.http || [];
          const addEthereumChain = {
            blockExplorerUrls,
            chainId: numberToHex(chainId),
            chainName: chainToSwitch.name,
            iconUrls: addEthereumChainParameter?.iconUrls,
            nativeCurrency: chainToSwitch.nativeCurrency,
            rpcUrls
          };
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [addEthereumChain]
          });
          const requestedChains = await this.getRequestedChainsIds();
          this.setRequestedChainsIds([...requestedChains, chainId]);
          return { ...chainToSwitch, id: chainToSwitch.id };
        } catch (e) {
          throw new UserRejectedRequestError(e);
        }
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0) {
        this.onDisconnect();
      } else {
        config.emitter.emit("change", {
          accounts: accounts.map((x) => getAddress(x))
        });
      }
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    onConnect(_connectInfo) {
      this.setRequestedChainsIds(ChainController.getCaipNetworks().map((x) => Number(x.id)));
    },
    async onDisconnect(_error) {
      this.setRequestedChainsIds([]);
      config.emitter.emit("disconnect");
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      if (sessionDelete) {
        provider.removeListener("session_delete", sessionDelete);
        sessionDelete = void 0;
      }
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider.on("connect", connect2);
      }
    },
    onDisplayUri(uri) {
      config.emitter.emit("message", { type: "display_uri", data: uri });
    },
    onSessionDelete() {
      this.onDisconnect();
    },
    getNamespaceChainsIds() {
      if (!provider_?.session?.namespaces) {
        return [];
      }
      const accounts = provider_?.session?.namespaces[ConstantsUtil.CHAIN.EVM]?.accounts;
      const chainIds = accounts?.map((account) => Number.parseInt(account.split(":")[1] ?? "")) ?? [];
      return chainIds;
    },
    async getRequestedChainsIds() {
      const chainIds = await config.storage?.getItem(this.requestedChainsStorageKey) ?? [];
      return [...new Set(chainIds)];
    },
    async isChainsStale() {
      if (!isNewChainsStale) {
        return false;
      }
      const connectorChains = config.chains.map((x) => x.id);
      const namespaceChains = this.getNamespaceChainsIds();
      if (namespaceChains.length && !namespaceChains.some((id) => connectorChains.includes(id))) {
        return false;
      }
      const requestedChains = await this.getRequestedChainsIds();
      return !connectorChains.every((id) => requestedChains.includes(Number(id)));
    },
    async setRequestedChainsIds(chains) {
      await config.storage?.setItem(this.requestedChainsStorageKey, chains);
    },
    get requestedChainsStorageKey() {
      return `${this.id}.requestedChains`;
    }
  }));
}

// node_modules/.pnpm/@reown+appkit-adapter-wagmi@1.7.8_@types+react@18.3.23_@wagmi+core@2.17.3_@tanstack+que_6d7829fc3866ba4c2f279130cedcf539/node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/utils/LimitterUtil.js
init_globalPolyfills();
var import_dist31 = __toESM(require_dist(), 1);
var import_dist32 = __toESM(require_dist2(), 1);
var import_dist33 = __toESM(require_dist3(), 1);
var state = proxy({
  pendingTransactions: 0
});
var LimitterUtil = {
  state,
  subscribeKey(key, callback) {
    return subscribeKey(state, key, callback);
  },
  increase(value) {
    state[value] += 1;
  },
  decrease(value) {
    state[value] -= 1;
  },
  reset(value) {
    state[value] = 0;
  }
};

// node_modules/.pnpm/@reown+appkit-adapter-wagmi@1.7.8_@types+react@18.3.23_@wagmi+core@2.17.3_@tanstack+que_6d7829fc3866ba4c2f279130cedcf539/node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/utils/helpers.js
init_globalPolyfills();
var import_dist34 = __toESM(require_dist(), 1);
var import_dist35 = __toESM(require_dist2(), 1);
var import_dist36 = __toESM(require_dist3(), 1);
function parseWalletCapabilities(str) {
  try {
    return JSON.parse(str);
  } catch (error) {
    throw new Error("Error parsing wallet capabilities");
  }
}
async function getSafeConnector(connectors) {
  if (CoreHelperUtil.isSafeApp()) {
    const { safe } = await import("./exports-G23YUCXU.js");
    if (safe && !connectors.some((c) => c.type === "safe")) {
      const safeConnector = safe();
      return safeConnector;
    }
  }
  return null;
}
async function getCoinbaseConnector(connectors) {
  try {
    const { coinbaseWallet } = await import("./exports-G23YUCXU.js");
    if (coinbaseWallet && !connectors.some((c) => c.id === "coinbaseWalletSDK")) {
      return coinbaseWallet();
    }
  } catch (error) {
    console.error("Failed to import Coinbase Wallet SDK:", error);
  }
  return null;
}

// node_modules/.pnpm/@reown+appkit-adapter-wagmi@1.7.8_@types+react@18.3.23_@wagmi+core@2.17.3_@tanstack+que_6d7829fc3866ba4c2f279130cedcf539/node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/client.js
var DEFAULT_PENDING_TRANSACTIONS_FILTER = {
  enable: false,
  pollingInterval: 3e4
};
var WagmiAdapter = class extends AdapterBlueprint {
  constructor(configParams) {
    const networks = CaipNetworksUtil.extendCaipNetworks(configParams.networks, {
      projectId: configParams.projectId,
      customNetworkImageUrls: {},
      customRpcUrls: configParams.customRpcUrls
    });
    super();
    this.balancePromises = {};
    this.namespace = ConstantsUtil.CHAIN.EVM;
    this.adapterType = ConstantsUtil.ADAPTER_TYPES.WAGMI;
    this.projectId = configParams.projectId;
    this.pendingTransactionsFilter = {
      ...DEFAULT_PENDING_TRANSACTIONS_FILTER,
      ...configParams.pendingTransactionsFilter ?? {}
    };
    this.createConfig({ ...configParams, networks });
    this.checkChainId();
  }
  construct(_options) {
    this.checkChainId();
    this.setupWatchers();
  }
  async getAccounts(params) {
    const connector = this.getWagmiConnector(params.id);
    if (!connector) {
      return { accounts: [] };
    }
    if (connector.id === ConstantsUtil.CONNECTOR_ID.AUTH) {
      const provider = await connector.getProvider();
      if (!provider?.user) {
        return { accounts: [] };
      }
      const { address: address2, accounts } = provider.user;
      return Promise.resolve({
        accounts: (accounts || [{ address: address2, type: "eoa" }]).map((account) => CoreHelperUtil.createAccount("eip155", account.address, account.type))
      });
    }
    const { addresses, address } = getAccount(this.wagmiConfig);
    return Promise.resolve({
      accounts: [...new Set(addresses || [address])]?.map((val) => CoreHelperUtil.createAccount("eip155", val || "", "eoa"))
    });
  }
  checkChainId() {
    const { chainId } = getAccount(this.wagmiConfig);
    if (chainId) {
      this.emit("switchNetwork", {
        chainId
      });
    }
  }
  getWagmiConnector(id) {
    return this.wagmiConfig.connectors.find((c) => c.id === id);
  }
  createConfig(configParams) {
    this.wagmiChains = configParams.networks.filter((caipNetwork) => caipNetwork.chainNamespace === ConstantsUtil.CHAIN.EVM);
    const transports = {};
    const connectors = [...configParams.connectors ?? []];
    this.wagmiChains.forEach((element) => {
      const fromTransportProp = configParams.transports?.[element.id];
      const caipNetworkId = CaipNetworksUtil.getCaipNetworkId(element);
      if (fromTransportProp) {
        transports[element.id] = CaipNetworksUtil.extendWagmiTransports(element, configParams.projectId, fromTransportProp);
      } else {
        transports[element.id] = CaipNetworksUtil.getViemTransport(element, configParams.projectId, configParams.customRpcUrls?.[caipNetworkId]);
      }
    });
    this.wagmiConfig = createConfig({
      ...configParams,
      chains: this.wagmiChains,
      connectors,
      transports
    });
  }
  setupWatchPendingTransactions() {
    if (!this.pendingTransactionsFilter.enable || this.unwatchPendingTransactions) {
      return;
    }
    this.unwatchPendingTransactions = watchPendingTransactions(this.wagmiConfig, {
      pollingInterval: this.pendingTransactionsFilter.pollingInterval,
      onError: () => {
      },
      onTransactions: () => {
        this.emit("pendingTransactions");
        LimitterUtil.increase("pendingTransactions");
      }
    });
    const unsubscribe = LimitterUtil.subscribeKey("pendingTransactions", (val) => {
      if (val >= ConstantsUtil.LIMITS.PENDING_TRANSACTIONS) {
        this.unwatchPendingTransactions?.();
        unsubscribe();
      }
    });
  }
  setupWatchers() {
    watchAccount(this.wagmiConfig, {
      onChange: (accountData, prevAccountData) => {
        if (accountData.status === "disconnected" && prevAccountData.address) {
          this.emit("disconnect");
        }
        if (accountData?.chainId && accountData?.chainId !== prevAccountData?.chainId) {
          this.emit("switchNetwork", {
            chainId: accountData.chainId
          });
        }
        if (accountData.status === "connected") {
          if (accountData.address !== prevAccountData?.address || prevAccountData.status !== "connected") {
            this.setupWatchPendingTransactions();
            this.emit("accountChanged", {
              address: accountData.address,
              chainId: accountData.chainId
            });
          }
        }
      }
    });
  }
  async addThirdPartyConnectors(options) {
    const thirdPartyConnectors = [];
    if (options.enableCoinbase !== false) {
      const coinbaseConnector = await getCoinbaseConnector(this.wagmiConfig.connectors);
      if (coinbaseConnector) {
        thirdPartyConnectors.push(coinbaseConnector);
      }
    }
    const safeConnector = await getSafeConnector(this.wagmiConfig.connectors);
    if (safeConnector) {
      thirdPartyConnectors.push(safeConnector);
    }
    await Promise.all(thirdPartyConnectors.map(async (connector) => {
      const cnctr = this.wagmiConfig._internal.connectors.setup(connector);
      this.wagmiConfig._internal.connectors.setState((prev) => [...prev, cnctr]);
      await this.addWagmiConnector(cnctr, options);
    }));
  }
  addWagmiConnectors(options, appKit) {
    const customConnectors = [];
    if (options.enableWalletConnect !== false) {
      customConnectors.push(walletConnect(options, appKit));
    }
    if (options.enableInjected !== false) {
      customConnectors.push(injected({ shimDisconnect: true }));
    }
    const isEmailEnabled = appKit?.remoteFeatures?.email ?? true;
    const socialsEnabled = Array.isArray(appKit?.remoteFeatures?.socials) && appKit?.remoteFeatures?.socials?.length > 0;
    if (isEmailEnabled || socialsEnabled) {
      customConnectors.push(authConnector({
        chains: this.wagmiChains,
        options: { projectId: options.projectId, enableAuthLogger: options.enableAuthLogger }
      }));
    }
    customConnectors.forEach((connector) => {
      const cnctr = this.wagmiConfig._internal.connectors.setup(connector);
      this.wagmiConfig._internal.connectors.setState((prev) => [...prev, cnctr]);
    });
  }
  async signMessage(params) {
    try {
      const signature = await signMessage(this.wagmiConfig, {
        message: params.message,
        account: params.address
      });
      return { signature };
    } catch (error) {
      throw new Error("WagmiAdapter:signMessage - Sign message failed");
    }
  }
  async sendTransaction(params) {
    const { chainId, address } = getAccount(this.wagmiConfig);
    const txParams = {
      account: address,
      to: params.to,
      value: Number.isNaN(Number(params.value)) ? BigInt(0) : BigInt(params.value),
      gas: params.gas ? BigInt(params.gas) : void 0,
      gasPrice: params.gasPrice ? BigInt(params.gasPrice) : void 0,
      data: params.data,
      chainId,
      type: "legacy",
      parameters: ["nonce"]
    };
    await prepareTransactionRequest(this.wagmiConfig, txParams);
    const tx = await sendTransaction(this.wagmiConfig, txParams);
    await waitForTransactionReceipt(this.wagmiConfig, { hash: tx, timeout: 25e3 });
    return { hash: tx };
  }
  async writeContract(params) {
    const { caipNetwork, ...data } = params;
    const chainId = Number(NetworkUtil.caipNetworkIdToNumber(caipNetwork.caipNetworkId));
    const tx = await writeContract(this.wagmiConfig, {
      chain: this.wagmiChains?.[chainId],
      chainId,
      address: data.tokenAddress,
      account: data.fromAddress,
      abi: data.abi,
      functionName: data.method,
      args: data.args,
      __mode: "prepared"
    });
    return { hash: tx };
  }
  async estimateGas(params) {
    try {
      const result = await estimateGas(this.wagmiConfig, {
        account: params.address,
        to: params.to,
        data: params.data,
        type: "legacy"
      });
      return { gas: result };
    } catch (error) {
      throw new Error("WagmiAdapter:estimateGas - error estimating gas");
    }
  }
  parseUnits(params) {
    return parseUnits(params.value, params.decimals);
  }
  formatUnits(params) {
    return formatUnits(params.value, params.decimals);
  }
  async addWagmiConnector(connector, options) {
    if (connector.id === ConstantsUtil.CONNECTOR_ID.AUTH || connector.id === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
      return;
    }
    const provider = await connector.getProvider().catch(() => void 0);
    this.addConnector({
      id: connector.id,
      explorerId: PresetsUtil.ConnectorExplorerIds[connector.id],
      imageUrl: options?.connectorImages?.[connector.id] ?? connector.icon,
      name: PresetsUtil.ConnectorNamesMap[connector.id] ?? connector.name,
      imageId: PresetsUtil.ConnectorImageIds[connector.id],
      type: PresetsUtil.ConnectorTypesMap[connector.type] ?? "EXTERNAL",
      info: connector.id === ConstantsUtil.CONNECTOR_ID.INJECTED ? void 0 : { rdns: connector.id },
      provider,
      chain: this.namespace,
      chains: []
    });
  }
  async syncConnectors(options, appKit) {
    watchConnectors(this.wagmiConfig, {
      onChange: (connectors) => {
        connectors.forEach((connector) => this.addWagmiConnector(connector, options));
      }
    });
    this.addWagmiConnectors(options, appKit);
    await this.addThirdPartyConnectors(options);
  }
  async syncConnection(params) {
    const { id, chainId } = params;
    const connections = getConnections(this.wagmiConfig);
    const connection = connections.find((c) => c.connector.id === id);
    const connector = this.getWagmiConnector(id);
    const provider = await connector?.getProvider();
    const isSafeApp = CoreHelperUtil.isSafeApp();
    if (isSafeApp && id === ConstantsUtil.CONNECTOR_ID.SAFE && !connection?.accounts.length) {
      const safeAppConnector = this.getWagmiConnector("safe");
      if (safeAppConnector) {
        const res = await connect(this.wagmiConfig, {
          connector: safeAppConnector,
          chainId: Number(chainId)
        });
        const safeProvider = await safeAppConnector.getProvider();
        return {
          chainId: Number(chainId),
          address: res.accounts[0],
          provider: safeProvider,
          type: connection?.connector.type?.toUpperCase(),
          id: connection?.connector.id
        };
      }
    }
    return {
      chainId: Number(connection?.chainId),
      address: connection?.accounts[0],
      provider,
      type: connection?.connector.type?.toUpperCase(),
      id: connection?.connector.id
    };
  }
  async connectWalletConnect(chainId) {
    const walletConnectConnector = this.getWalletConnectConnector();
    await walletConnectConnector.authenticate();
    const wagmiConnector = this.getWagmiConnector("walletConnect");
    if (!wagmiConnector) {
      throw new Error("UniversalAdapter:connectWalletConnect - connector not found");
    }
    const res = await connect(this.wagmiConfig, {
      connector: wagmiConnector,
      chainId: chainId ? Number(chainId) : void 0
    });
    if (res.chainId !== Number(chainId)) {
      await switchChain(this.wagmiConfig, { chainId: res.chainId });
    }
    return { clientId: await walletConnectConnector.provider.client.core.crypto.getClientId() };
  }
  async connect(params) {
    const { id, provider, type, info, chainId, socialUri } = params;
    const connector = this.getWagmiConnector(id);
    if (!connector) {
      throw new Error("connectionControllerClient:connectExternal - connector is undefined");
    }
    if (provider && info && connector.id === ConstantsUtil.CONNECTOR_ID.EIP6963) {
      connector.setEip6963Wallet?.({ provider, info });
    }
    if (connector.uid === this.wagmiConfig?.state?.current) {
      const connection = this.wagmiConfig.state?.connections?.get(connector.uid);
      if (connection) {
        return {
          address: connection?.accounts[0],
          chainId: connection?.chainId,
          provider,
          type,
          id
        };
      }
    }
    const res = await connect(this.wagmiConfig, {
      connector,
      chainId: chainId ? Number(chainId) : void 0,
      socialUri
    });
    return {
      address: res.accounts[0],
      chainId: res.chainId,
      provider,
      type,
      id
    };
  }
  async reconnect(params) {
    const { id } = params;
    const connector = this.getWagmiConnector(id);
    if (!connector) {
      throw new Error("connectionControllerClient:connectExternal - connector is undefined");
    }
    await reconnect(this.wagmiConfig, {
      connectors: [connector]
    });
  }
  async getBalance(params) {
    const address = params.address;
    const caipNetwork = this.getCaipNetworks().find((network) => network.id === params.chainId);
    if (!address) {
      return Promise.resolve({ balance: "0.00", symbol: "ETH" });
    }
    if (caipNetwork && this.wagmiConfig) {
      const caipAddress = `${caipNetwork.caipNetworkId}:${params.address}`;
      const cachedPromise = this.balancePromises[caipAddress];
      if (cachedPromise) {
        return cachedPromise;
      }
      const cachedBalance = StorageUtil.getNativeBalanceCacheForCaipAddress(caipAddress);
      if (cachedBalance) {
        return { balance: cachedBalance.balance, symbol: cachedBalance.symbol };
      }
      this.balancePromises[caipAddress] = new Promise(async (resolve) => {
        try {
          const chainId = Number(params.chainId);
          const balance = await getBalance(this.wagmiConfig, {
            address: params.address,
            chainId,
            token: params.tokens?.[caipNetwork.caipNetworkId]?.address
          });
          StorageUtil.updateNativeBalanceCache({
            caipAddress,
            balance: balance.formatted,
            symbol: balance.symbol,
            timestamp: Date.now()
          });
          resolve({ balance: balance.formatted, symbol: balance.symbol });
        } catch (error) {
          console.warn("Appkit:WagmiAdapter:getBalance - Error getting balance", error);
          resolve({ balance: "0.00", symbol: "ETH" });
        }
      }).finally(() => {
        delete this.balancePromises[caipAddress];
      });
      return this.balancePromises[caipAddress] || { balance: "0.00", symbol: "ETH" };
    }
    return { balance: "", symbol: "" };
  }
  getWalletConnectProvider() {
    return this.getWagmiConnector("walletConnect")?.["provider"];
  }
  async disconnect() {
    const connections = getConnections(this.wagmiConfig);
    await Promise.allSettled(connections.map(async (connection) => {
      const connector = this.getWagmiConnector(connection.connector.id);
      if (connector) {
        await disconnect(this.wagmiConfig, { connector });
      }
    }));
    this.wagmiConfig.state.connections.clear();
  }
  async switchNetwork(params) {
    await switchChain(this.wagmiConfig, { chainId: params.caipNetwork.id });
    await super.switchNetwork(params);
  }
  async getCapabilities(params) {
    if (!this.wagmiConfig) {
      throw new Error("connectionControllerClient:getCapabilities - wagmiConfig is undefined");
    }
    const connections = getConnections(this.wagmiConfig);
    const connection = connections[0];
    const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
    if (!connector) {
      throw new Error("connectionControllerClient:getCapabilities - connector is undefined");
    }
    const provider = await connector.getProvider();
    if (!provider) {
      throw new Error("connectionControllerClient:getCapabilities - provider is undefined");
    }
    const walletCapabilitiesString = provider.session?.sessionProperties?.["capabilities"];
    if (walletCapabilitiesString) {
      const walletCapabilities = parseWalletCapabilities(walletCapabilitiesString);
      const accountCapabilities = walletCapabilities[params];
      if (accountCapabilities) {
        return accountCapabilities;
      }
    }
    return await provider.request({ method: "wallet_getCapabilities", params: [params] });
  }
  async grantPermissions(params) {
    if (!this.wagmiConfig) {
      throw new Error("connectionControllerClient:grantPermissions - wagmiConfig is undefined");
    }
    const connections = getConnections(this.wagmiConfig);
    const connection = connections[0];
    const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
    if (!connector) {
      throw new Error("connectionControllerClient:grantPermissions - connector is undefined");
    }
    const provider = await connector.getProvider();
    if (!provider) {
      throw new Error("connectionControllerClient:grantPermissions - provider is undefined");
    }
    return provider.request({ method: "wallet_grantPermissions", params });
  }
  async revokePermissions(params) {
    if (!this.wagmiConfig) {
      throw new Error("connectionControllerClient:revokePermissions - wagmiConfig is undefined");
    }
    const connections = getConnections(this.wagmiConfig);
    const connection = connections[0];
    const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
    if (!connector) {
      throw new Error("connectionControllerClient:revokePermissions - connector is undefined");
    }
    const provider = await connector.getProvider();
    if (!provider) {
      throw new Error("connectionControllerClient:revokePermissions - provider is undefined");
    }
    return provider.request({ method: "wallet_revokePermissions", params });
  }
  async walletGetAssets(params) {
    if (!this.wagmiConfig) {
      throw new Error("connectionControllerClient:walletGetAssets - wagmiConfig is undefined");
    }
    const connections = getConnections(this.wagmiConfig);
    const connection = connections[0];
    const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
    if (!connector) {
      throw new Error("connectionControllerClient:walletGetAssets - connector is undefined");
    }
    const provider = await connector.getProvider();
    if (!provider) {
      throw new Error("connectionControllerClient:walletGetAssets - provider is undefined");
    }
    return provider.request({ method: "wallet_getAssets", params: [params] });
  }
  setUniversalProvider(universalProvider) {
    universalProvider.on("connect", () => {
      const connections = getConnections(this.wagmiConfig);
      const connector = this.getWagmiConnector("walletConnect");
      if (connector && !connections.find((c) => c.connector.id === connector.id)) {
        reconnect(this.wagmiConfig, {
          connectors: [connector]
        });
      }
    });
    this.addConnector(new WalletConnectConnector({
      provider: universalProvider,
      caipNetworks: this.getCaipNetworks(),
      namespace: "eip155"
    }));
  }
};
export {
  WagmiAdapter,
  authConnector
};
//# sourceMappingURL=@reown_appkit-adapter-wagmi.js.map
